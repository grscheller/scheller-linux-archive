Notes taken while configuring Arch Linux for Python development.

2022-01-27:
  I really need to better grok Python virtual environments.

    $ pacman -Ss virtualenv
    extra/python-virtualenv 20.11.0-1
        Virtual Python Environment builder
    community/python-pipenv 2022.1.8-2
        Sacred Marriage of Pipfile, Pip, & Virtualenv.
    community/python-pytest-virtualenv 1.7.0-8
        Virtualenv fixture for py.test
    community/python-selinux 0.2.1-7
        Pure-python selinux shim module for use in virtualenvs
    community/python-tox 3.24.5-1
        Python virtualenv management and testing tool
    community/python-virtualenv-clone 0.5.7-3
        A script for cloning a non-relocatable virtualenv.
    community/python-virtualenvwrapper 4.8.4-6
        Extensions to Ian Bicking's virtualenv tool

  I had remembered pipenv but had fotgotten its name.  Totally
  bootstrapping from userland, I would need the following

    $ pacman -Ss pipx
    community/python-pipx 0.16.4-2
        Install and Run Python Applications in Isolated Environments

  but since I can install pipenv with pacman into the system Python
  environment, and I don't intend to hop between different installed
  Python versions, I think just installing pipenv package should be
  enough.

  Here is what I got installed on Arch,

    $ python --version
    Python 3.10.2

    $ pip --version
    pip 20.3.4 from /usr/lib/python3.10/site-packages/pip (python 3.10)

    $ pip3 --version
    pip 20.3.4 from /usr/lib/python3.10/site-packages/pip (python 3.10)

    $ pip3.10 --version
    pip 20.3.4 from /usr/lib/python3.10/site-packages/pip (python 3.10)

  Let's see where Python will look for user stuff,

    $ python -m site --user-base
    /home/grs/.local

    $ python -m site --user-site
    /home/grs/.local/lib/python3.10/site-packages

  Installing pipenv system wide.

    $ sudo pacman -Syu python-pipenv
    ...
    Packages (8) python-certifi-2021.10.8-3  python-filelock-3.4.0-3
      python-importlib-metadata-4.8.1-3  python-platformdirs-2.4.1-1
      python-virtualenv-20.11.0-1  python-virtualenv-clone-0.5.7-3
      python-zipp-3.7.0-1  python-pipenv-2022.1.8-2

  Thought it would install Python Virtualenv as a dependency.

2022-01-27:
  While I am at it, I might as well look into the capability of
  installing and switching between multiple verions of Python.

    $ pacman -Ss pyenv
    community/pyenv 2.2.4-1
        Easily switch between multiple versions of Python

    $ pacman -Qlq pyenv|grep '^/usr/bin/..*'
    /usr/bin/pyenv
    /usr/bin/pyenv-install
    /usr/bin/pyenv-uninstall
    /usr/bin/python-build

  These look to be Bash scripts.  Does have fish, and zsh, support.

    $ pacman -Qlq pyenv|grep fish
    /usr/share/fish/
    /usr/share/fish/vendor_completions.d/
    /usr/share/fish/vendor_completions.d/pyenv.fish

2022-01-28:
  There exists a pyenv extension called pyenv-virtualenv for working
  with virtualenv with pyenv.  Does not seem to be a package for
  this in the regular Arch Repos.

  The Github pyenv repo

    https://github.com/pyenv/pyenv-install

  states "Of course, you can create virtualenv yourself, or
  pyenv-virtualenv to automate the process."  I am choosing
  to manage my virtual environments myself with pipenv.

  Another good pyenv resource is the website
  "Pipenv: Python Dev Workflow for Humans"

    https://pipenv.pypa.io/en/latest/

  I intend to establish a coherent Python environment with the
  system pyenv and manage the individual virtual environments
  with that Python's pipenv.

2022-01-28:
  Pipenv documentation resides here,

    https://pipenv.pypa.io/en/latest/

  on the Python Packaging Authority website.

  Quoted material below is pulled verbatim from above documentation.

  Pipenv "automatically creates and manages a virtualenv for your
  projects, as well as adds/removes packages from your Pipfile as
  you install/uninstall packages. It also generates the ever-important
  Pipfile.lock, which is used to produce deterministic builds."

  Pipfile vs. setup.py.  Hopefully, I won't have to bother grokking
  how to use setuptools directly.

    $ pacman -Ss python-setuptools\$
    extra/python-setuptools 1:59.1.1-1 [installed]
        Easily download, build, install, upgrade, and uninstall Python packages

    $ pactree -r python-setuptools
    python-setuptools
    ├─python-distro
    │ └─python-pip
    │   └─python-pipenv
    └─python-pip

2022-01-28:
  Updated my fish and bash environments for pyenv.  See my commit
  dated Fri Jan 28 16:39:42 2022 -0700 on my dotfiles repo

    https://github.com/grscheller/dotfiles

  Seems to work on both Arch Linux and MacOS.  Actually I didn't remember
  installing pyenv on my iMac and could not test how startup scripts behaved
  when pyenv not installed.  Pyenv configured and installed on euler7.
  Will test on gauss17 where I have not installed pyenv yet.

  On euler7:

    # pyenv install 3.11-dev
    Cloning https://github.com/python/Python-3.11-dev
    Installing to /home/grs/.pyenv/versions/3.11-dev

    $ pyenv versions
    * system (set by /home/grs/.pyenv/version)
      3.11-dev

    $ pyenv version
    system (set by /home/grs/.pyenv/version)

    $ pyenv --version
    pyenv 2.2.4

  Here is what one of the shims looks like

    $ cat .pyenv/shims/pip
    #!/usr/bin/env bash
    set -e
    [ -n "$PYENV_DEBUG" ] && set -x

    program="${0##*/}"

    export PYENV_ROOT="/home/grs/.pyenv"
    exec "/usr/share/pyenv/libexec/pyenv" exec "$program" "$@"

2022-01-29:
  Installed pyenv on gauss17 also.

  On euler7:

    Bootstrapped pyenv config by createing empty ~/.pyenv
    directory and relogged in.  (Arch Linux)

  On sc31:

    I seemed to have had already had pyenv installed via
    brew and when I pushed my shell environment over, pyenv
    configured itself. (MacOS)

    I noticed that on iMac alot of the base directory files
    from the Pyenv Github repo got installed in ~/.pyenv/,
    did brew clone the Github repo?

  On gauss17:

    Bootstrapped pyenv via a terminal session,

      $ eval pyenv init - fish | source

    This did exactly the same as on euler7,

       $ ls -A ~/.pyenv/*
       /home/grs/.pyenv/shims:

       /home/grs/.pyenv/versions:

     No Github clutter.

2022-01-29:
  Why is ~/.pyenv/shims/ empty on gauss17?  Only thing different I
  really did was installed Python 3.11-dev.python -m tkinter

  To list all versions of "things" that Pyenv can install

    $ pyenv install --list

  Which one do I want to install?  Hmmm...

  Aside:

    Since I am doing a Django project, lets go with some older
    Python version supported by whatever verson of Django is
    installed by Pacman.

      $ pacman -Qs django
      local/python-django 3.2.10-1
          A high-level Python Web framework that encourages rapid
          development and clean design

    Django release schedule,

    Series   Release/Date   End support       End extended support
    2.2 LTS  2.2.26         December 2, 2019  April 2022
    3.2 LTS  3.2.11         December 2021     April 2024
    4.0      4.0.1          August 2022       April 2023
    4.1      August 2022    April 2023        December 2023
    4.2 LTS  April 2023     December 2023     April 2026
    5.0      December 2023  August 2024       April 2025

    Django 3.2 supports Python 3.6, 3.7, 3.8, 3.9, and 3.10 (as of 3.2.9)
    Django 4.0 supports Python 3.8, 3.9, and 3.10

    Also, Django website: https://www.djangoproject.com/ states

        "We highly recommend and only officially
         support the latest release of each series"

    I going to see if I can build my project in three configurations

      * Django 3.2 LTS using Python 3.8.12
      * Django 4.0 using Python 3.10.2 (Update when 4.2 LTS available)
      * System Django & Python, currently 3.2.10 and 3.10.2 respectively

    The last one will "roll" with Arch Linux.

  Ok, I will install Python 3.8.12 and 3.10.2 via pyenv.

    $ pyenv install 3.8.12
    $ pyenv install 3.10.2

    $ pyenv versions
    * system (set by /home/grs/.pyenv/version)
      3.10.2
      3.8.12

2022-01-31:
  Will need to understand how to use virtualenv and how it interacts
  with pyenv.

    $ digpath pip
    /home/grs/.pyenv/shims/pip
    /usr/bin/pip

  We find pip's shim first, which should currently point to the
  system's pip.

    $ pip --version
    pip 20.3.4 from /usr/lib/python3.10/site-packages/pip (python 3.10)

    $ /usr/bin/pip --version
    pip 20.3.4 from /usr/lib/python3.10/site-packages/pip (python 3.10)

    $ pyenv whence pip
    3.10.2
    3.8.12

    $ pyenv which pip
    /usr/bin/pip

  Let's do the same for virtualenv, note: I have not installed the
  pyenv-virtualenv plugin to pyenv since I want to use pipenv.

    $ digpath virtualenv
    /usr/bin/virtualenv

    $ pyenv whence virtualenv

    $ pyenv which virtualenv
    /usr/bin/virtualenv

  As well as for pipenv.

    $ digpath pipenv
    /usr/bin/pipenv

    $ pyenv whence pipenv

    $ pyenv which pipenv
    /usr/bin/pipenv

  Nobody home for pipenv and virtualenv for the pyenv locally installed
  Python versions.  I guess I will need to install pipenv, probably the
  only thing for which I will use pip directly.

2022-01-31:
  Here are two fairly recent blog posts which describe how to use
  Pyenv and Pipenv together:

    https://www.rootstrap.com/blog/how-to-manage-your-python-projects-with-pipenv-pyenv/
    https://hackernoon.com/reaching-python-development-nirvana-bb5692adf30c

  The Pipenv site also has information on Pyenv:

    https://pipenv.pypa.io/en/latest/
    https://pipenv.pypa.io/en/latest/advanced/

  This is a big change from 5 months ago when I was going in circles
  with Pipenv, Pipfile, and setup.py.

  Note to self: learn distinction between

    Pipfile & Pipfile.lock vs. setup.py

  The first two lock down a build while the later one puts
  constraints on library dependencies.  The first two replace
  the old requirements.txt mechanism.

2022-02-14:
  Look into HallerPatrick/py_lsp.nvim.  Might be useful if it
  turns out that LSP has trouble distinguishing the environment
  of the Python running in nvim vs virtual environment of the
  code being edited.

  I would like to keep my Python virtual environments as lean
  as possible and not have to install pynvim and pipenv into
  every one of them.

  See 2022-09-13

2022-02-15:
  Beginning to understand that pipenv is not a pip replacement and
  pip still has its use case.

  Pipenv manages a software project with a virtual enviroment.
  Pip manages an installed Python environment.  Pipenv will
  use pip under the hood to manage the virtual environment.

  I still use pip to manage the Python environments I install
  with pyenv.

  Here is an example workflow.  In my Neovim init.lua configs I set

    vim.g.python3_host_prog = os.getenv("HOME") .. '/.pyenv/shims/python'

  Install a version of Python

    $ pyenv install 3.9.7
    $ pyenv global 3.9.7
    $ PIP_REQUIRE_VIRTUALENV=false pip install pip --upgrade
    $ PIP_REQUIRE_VIRTUALENV=false pip install pipenv
    $ PIP_REQUIRE_VIRTUALENV=false pip install pynvim
    $ pyenv global system

  Initialize a new project and associate virtual environment

    $ mkdir junk; cd junk
    $ pyenv local 3.9.7  # pipenv will do below without this
    $ pipenv --python 3.9.7
    Creating a virtualenv for this project...
    Pipfile: /home/grs/junk/Pipfile
    Using /home/grs/.pyenv/versions/3.9.7/bin/python3.9 (3.9.7) to create virtualenv...
    ⠸ Creating virtual environment...created virtual environment CPython3.9.7.final.0-64 in 146ms
      creator CPython3Posix(dest=/home/grs/.local/share/virtualenvs/junk-Jrpe9XOJ, clear=False, no_vcs_ignore=False, global=False)
      seeder FromAppData(download=False, pip=bundle, setuptools=bundle, wheel=bundle, via=copy, app_data_dir=/home/grs/.local/share/virtualenv)
        added seed packages: pip==21.3.1, setuptools==60.1.0, wheel==0.37.1
      activators BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator,PythonActivator

  and switch to it

    $ pipenv shell
    Launching subshell in virtual environment...
     source /home/grs/.local/share/virtualenvs/junk-Jrpe9XOJ/bin/activate.fish
    (junk)$ ls
    Pipfile
    (junk)$ cat Pipfile
    [source]]
    url = "https://pypi.org/simple"
    verify_ssl = true
    name = "pypi"

    [packages]

    [dev-packages]

    [requires]
    python_version = "3.9"
    (junk)$ python --version
    Python 3.9.7

  I beleive (need to verify) that nvim itself will still use the same
  version of Python used in the virtual environment, but run outside it.

  At least :checkhealth is OK.  Also python run against the virtual
  environment cannot import pynvim; while run against the underlying
  3.9.7 environment can.

  To cleanup when done,

    (junk)$ exit
    $ pipenv --rm
    Removing virtualenv (/home/grs/.local/share/virtualenvs/junk-Jrpe9XOJ)...
    $ cd ..
    $ rm -rf junk/

2022-09-13:
  I almost forgot most of this!  Thank God I wrote the above all down.

  * To manage multiple python versions: pyenv
      - pyenv-virtualenv plugin to manage virtual environments (not used)
        - using pipenv in lieu of this
    To manage virtual environments: venv (not using directly)
      - come with Python 3.3+
      - recommended by pypa
      - by default, puts virtual environment in project subdirectory
      - when used directly, need pip to install packages
      - virtualenv manages virtual enviroGnments (not using)
        - original tool which venv depricated
        - seems future goals are to be very cross OS and cross Python version compatible
        - popular with Python 2.7 clingers
      - virtualenvwrapper gives convinence Python programs to manage virtual environments (not using)
        - uses venv when it can
        - not sure how it handles multiple installed Python versions
          - does it need to be installed separately on every installed Python?
          - maybe could use pipenvwrapper?
    To install Python packages: pip (not usually used directly)
      - official package installer for Python
      - packages installed from the Python Package Index and other indexes
  * To Manage your Python projects/packages/applications: pipenv
      - wrapper function for pip and venv
      - automatically creates and manages a virtualenv for your projects
      - adds/removes packages from your Pipfile as you install/uninstall Packages
      - generates Pipfile.lock file for deterministic builds
      - pipenvwrapper adds convinence shell function to POSIX like shells (not using)
        - not POSIX compatible shellscripting
        - bash, ksh, zsh lowest common denominator shell meta programming

  For more information, see

    - https://pipenv.pypa.io/en/latest/
    - https://pipenv.pypa.io/en/latest/install/
    - https://pipenv.pypa.io/en/latest/advanced/

2022-10-18:
  I am thinking about use cases for pyenv and pipenv.

  1. Maintain a personnel Python environment for my Linux user.  Basically
     installing packages I write and the dependencies they require.  Would
     be contained in its own virtual environment.  The global default
     pipenv for my user.  It would use the Arch system Python.

  2. Development environments where I develop the packages I install.
     Try to make as minimal as possible.

  3. Specialty environments where I compartmentalize apps whose dependencies
     are fragile or out of date.  Web based stuff for example, where
     all the dependies go down like turtles.  May need to even use old
     versions of Python.

  4. A sandbox for pypy3?  Could I create a shared virtual environment
     with pypy3 and python?

2022-10-18:
  To do a "health check" against your virtual environment,

    $ pipenv check

  After editing Pipfile, may need to blow away your virtual environment.

    $ pipenv --rm

  I did another `pipenv check` and pipenv created a new virtualenv.  Not
  sure how it would handle external dependencies since my project had
  none.  Pipfile does have infrastrucure for private Python repos.

  See: https://medium.com/hackernoon/reaching-python-development-nirvana-bb5692adf30c

2022-10-19:
  After pulling scheller-linux-archive repo to gauss17, only problem was
  that .python-version was not set to the system Python.

  See: https://github.com/neovim/nvim-lspconfig/issues/717

  for some insight on how pyenv and pipenv interact.

  Seems that pipenv will set $VIRTUAL_ENV and prepend the bin directory
  of that virtual enviroment to your $PATH before the pyenv shim.

2022-10-19:
  Will do a Neovim :checkhealth outside and within the pipenv virtual
  environment.

  Outside:

    ## nvim-lsp-installer report
      - OK: neovim version >= 0.7.0

    ## Python 3 provider (optional)
      - INFO: pyenv: Path: /usr/share/pyenv/libexec/pyenv
      - INFO: pyenv: Root: /home/grs/.pyenv
      - INFO: Using: g:python3_host_prog = "/home/grs/.pyenv/shims/python"
      - INFO: Executable: /home/grs/.pyenv/shims/python
      - INFO: Python version: 3.10.8
      - INFO: pynvim version: 0.4.3
      - OK: Latest pynvim is installed.

    ## Python virtualenv
      - OK: no $VIRTUAL_ENV

  Inside:

    ## nvim-lsp-installer report
      - OK: neovim version >= 0.7.0

    ## Python 3 provider (optional)
      - INFO: pyenv: Path: /usr/share/pyenv/libexec/pyenv
      - INFO: pyenv: Root: /home/grs/.pyenv
      - INFO: Using: g:python3_host_prog = "/home/grs/.pyenv/shims/python"
      - INFO: Executable: /home/grs/.pyenv/shims/python
      - ERROR: Command error (job=5, exit code 1): `/home/grs/.pyenv/shims/python -c 'import sys; sys.path = [p for p in sys.path if p != ""]; import neovim; print(neovim.__file__)'` (in '/home/grs/devel/scheller-linux-archive/grok/Python/boring_math')
        stderr: Traceback (most recent call last):  File "<string>", line 1, in <module>ModuleNotFoundError: No module named 'neovim'
      - INFO: Python version: 3.10.8
      - INFO: pynvim version: unable to load neovim Python module
      - ERROR: pynvim is not installed.
        Error: unable to load neovim Python module
        - ADVICE:
          - Run in shell: /home/grs/.pyenv/shims/python -m pip install pynvim

    ## Python virtualenv
      - INFO: $VIRTUAL_ENV is set to: /home/grs/.local/share/virtualenvs/boring_math-7KsFA2pk
      - INFO: Python version: 3.10.8
      - OK: $VIRTUAL_ENV provides :!python.

  Now, looks to be only a little bit broken:

  1. Looks like pynvim needs to be installed into the virtualenv.  Instead
     of manually using pip, we can install it thru the [dev-packages]
     section of Pipfile.
  2. Can we also install pipenv into each virtual environment via the
     Pipefile too?  Seems like a chicken and egg situation.
  3. Why did pipenv even work with boring_math even when it was not
     installed into the virtual invironment???  I guess it only needs to
     be installed in the the base Python environment, no matter whether
     it is the system Python or a Python installed by pyenv!  Pipenv
     does not know anything about pyenv.
  4. Maybe I should not define python3_host_prog in my nvim configs?
  5. Maybe I should not run pipenv commands within a pipenv shell?

  Beginning to understand enough so that this blog makes sense:

    http://murawski.blog/pyenv-pipenv.html

2022-10-20:
  Once you use pyenv to set up which VERSION of Python to use, THAT
  is the version which pipenv will know about.  If python runs with
  that version but NOT in a virtual environment, will pyright LSP
  know to use the virtual environment?  Not clear to me.

    $ pyenv versions
    * system (set by /home/grs/.pyenv/version)
      3.10.6
      3.10.7

    $ pipenv run python -m pip list
    Package    Version
    ---------- -------
    pip        22.2.1
    setuptools 63.2.0
    wheel      0.37.1

  Just to be sure, pointing python3_host_prog to the pyenv shim,
  then run nvim in the virtual environment.

    vim.g.python3_host_prog = os.getenv('HOME') .. '/.pyenv/shims/python'

  Will need to install pynvim into each virtual environment.
  I am not sure the pyright LSP server will use the correct
  virtual environment when nvim itself is using the base pyenv
  python environment.

    $ pipenv install --dev pynvim
    Installing pynvim...
    Adding pynvim to Pipfile's [dev-packages]...
    ✔ Installation Succeeded
    Pipfile.lock (e4eef2) out of date, updating to (5d7155)...
    Locking [packages] dependencies...
    Locking [dev-packages] dependencies...
    Building requirements...
    Resolving dependencies...
    ✔ Success!
    Updated Pipfile.lock (5d7155)!
    Installing dependencies from Pipfile.lock (5d7155)...
    To activate this project's virtualenv, run pipenv shell.
    Alternatively, run a command inside the virtualenv with pipenv run.

    $ pipenv run python -m pip list
    Package    Version
    ---------- -----------
    greenlet   1.1.3.post0
    msgpack    1.0.4
    pip        22.2.1
    pynvim     0.4.3
    setuptools 63.2.0
    wheel      0.37.1

  Now, :checkhealth gives

    ## Python 3 provider (optional)
      - INFO: pyenv: Path: /usr/share/pyenv/libexec/pyenv
      - INFO: pyenv: Root: /home/grs/.pyenv
      - INFO: Using: g:python3_host_prog = "/home/grs/.pyenv/shims/python"
      - INFO: Executable: /home/grs/.pyenv/shims/python
      - INFO: Python version: 3.10.8
      - INFO: pynvim version: 0.4.3
      - OK: Latest pynvim is installed.

    ## Python virtualenv
      - INFO: $VIRTUAL_ENV is set to: /home/grs/.local/share/virtualenvs/boring_math-7KsFA2pk
      - INFO: Python version: 3.10.8
      - OK: $VIRTUAL_ENV provides :!python.

  and Pipfile contains

    [[source]]
    url = "https://pypi.org/simple"
    verify_ssl = true
    name = "pypi"

    [packages]

    [dev-packages]
    pynvim = "*"

    [requires]
    python_version = "3.10"

2022-10-20:
  Hopped back to euler7 to see effect of changes from earlier today.  After
  git pull,

    $ pipenv update

  was not pulling in pynvim.  I had to do a do a manual

    $ pipenv install pynvim

  To get pynvim installed.  This triggered the Pipfile.lock to be
  regenerated.  Later, when trying to reproduce the problem,

    $ pipenv update
    Running $ pipenv lock then $ pipenv sync.
    Locking [packages] dependencies...
    Building requirements...
    Resolving dependencies...
    ✔ Success!
    Locking [dev-packages] dependencies...
    Building requirements...
    Resolving dependencies...
    ✔ Success!
    Updated Pipfile.lock (16b8f2)!
    Installing dependencies from Pipfile.lock (16b8f2)...
    To activate this project's virtualenv, run pipenv shell.
    Alternatively, run a command inside the virtualenv with pipenv run.
    All dependencies are now up-to-date!

    [euler7: ~/devel/scheller-linux-archive/grok/Python/boring_math] (master|✚ =)
    $ pipenv run python -m pip list
    Package    Version
    ---------- -----------
    greenlet   1.1.3.post0
    msgpack    1.0.4
    pip        22.0.3
    pynvim     0.4.3
    setuptools 60.6.0
    wheel      0.37.1

  But,

    $ git diff Pipfile | cat
    diff --git a/grok/Python/boring_math/Pipfile b/grok/Python/boring_math/Pipfile
    index 3382f0c..c728d8f 100644
    --- a/grok/Python/boring_math/Pipfile
    +++ b/grok/Python/boring_math/Pipfile
    @@ -4,6 +4,7 @@ verify_ssl = true
     name = "pypi"

     [packages]
    +pynvim = "*"

     [dev-packages]
     pynvim = "*"

  Opps, my bad.  Forgot the --dev

    $ pipenv uninstall pynvim
    Uninstalling pynvim...
    Found existing installation: pynvim 0.4.3
    Uninstalling pynvim-0.4.3:
      Successfully uninstalled pynvim-0.4.3

    $ pipenv install --dev pynvim
    Installing pynvim...
    Adding pynvim to Pipfile's [dev-packages]...
    ✔ Installation Succeeded
    Pipfile.lock (e4eef2) out of date, updating to (5d7155)...
    Locking [packages] dependencies...
    Locking [dev-packages] dependencies...
    Building requirements...
    Resolving dependencies...
    ✔ Success!
    Updated Pipfile.lock (5d7155)!
    Installing dependencies from Pipfile.lock (5d7155)...
    To activate this project's virtualenv, run pipenv shell.
    Alternatively, run a command inside the virtualenv with pipenv run.

    $ pipenv run python -m pip list
    Package    Version
    ---------- -----------
    greenlet   1.1.3.post0
    msgpack    1.0.4
    pip        22.0.3
    pynvim     0.4.3
    setuptools 60.6.0
    wheel      0.37.1

    $ git diff Pipfile | cat

    $

  Let's see if we can reproduce the virtual environment after blowing
  it away.

    $ pipenv --rm
    Removing virtualenv (/home/grs/.local/share/virtualenvs/boring_math-7KsFA2pk)...

    $ cat Pipfile
    [[source]]
    url = "https://pypi.org/simple"
    verify_ssl = true
    name = "pypi"

    [packages]

    [dev-packages]
    pynvim = "*"

    [requires]
    python_version = "3.10"

    $ pipenv install
    Creating a virtualenv for this project...
    Pipfile: /home/grs/devel/scheller-linux-archive/grok/Python/boring_math/Pipfile
    Using /usr/bin/python3 (3.10.8) to create virtualenv...
    ⠧ Creating virtual environment...created virtual environment CPython3.10.8.final.0-64 in 348ms
      creator Venv(dest=/home/grs/.local/share/virtualenvs/boring_math-7KsFA2pk, clear=False, no_vcs_ignore=False, global=False, describe=CPython3Posix)
      seeder FromAppData(download=False, pip=bundle, setuptools=bundle, wheel=bundle, via=copy, app_data_dir=/home/grs/.local/share/virtualenv)
        added seed packages: pip==22.2.1, setuptools==63.2.0, wheel==0.37.1
      activators BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator,PythonActivator

    ✔ Successfully created virtual environment!
    Virtualenv location: /home/grs/.local/share/virtualenvs/boring_math-7KsFA2pk
    Installing dependencies from Pipfile.lock (5d7155)...
    To activate this project's virtualenv, run pipenv shell.
    Alternatively, run a command inside the virtualenv with pipenv run.

    $ pipenv run python -m pip list
    Package    Version
    ---------- -------
    pip        22.2.1
    setuptools 63.2.0
    wheel      0.37.1

    $ pipenv install --dev
    Installing dependencies from Pipfile.lock (5d7155)...
    To activate this project's virtualenv, run pipenv shell.
    Alternatively, run a command inside the virtualenv with pipenv run.

    $ pipenv run python -m pip list
    Package    Version
    ---------- -----------
    greenlet   1.1.3.post0
    msgpack    1.0.4
    pip        22.2.1
    pynvim     0.4.3
    setuptools 63.2.0
    wheel      0.37.1

    $ git status
    On branch master
    Your branch is up to date with 'origin/master'.

    nothing to commit, working tree clean

  Try some Neovim health checks,

  First:

    $ pipenv run nvim bin/pythag3.py
    :healthcheck

    ## Python 3 provider (optional)
      - INFO: pyenv: Path: /usr/share/pyenv/libexec/pyenv
      - INFO: pyenv: Root: /home/grs/.pyenv
      - INFO: Using: g:python3_host_prog = "/home/grs/.pyenv/shims/python"
      - INFO: Executable: /home/grs/.pyenv/shims/python
      - INFO: Python version: 3.10.8
      - INFO: pynvim version: 0.4.3
      - OK: Latest pynvim is installed.

    ## Python virtualenv
      - INFO: $VIRTUAL_ENV is set to: /home/grs/.local/share/virtualenvs/boring_math-7KsFA2pk
      - INFO: Python version: 3.10.8
      - OK: $VIRTUAL_ENV provides :!python.

  Second:

    $ nvim bin/pythag3.py
    :healthcheck

    ## Python 3 provider (optional)
      - INFO: pyenv: Path: /usr/share/pyenv/libexec/pyenv
      - INFO: pyenv: Root: /home/grs/.pyenv
      - INFO: Using: g:python3_host_prog = "/home/grs/.pyenv/shims/python"
      - INFO: Executable: /home/grs/.pyenv/shims/python
      - INFO: Python version: 3.10.8
      - INFO: pynvim version: 0.4.3
      - OK: Latest pynvim is installed.

    ## Python virtualenv
      - OK: no $VIRTUAL_ENV

  Since the pyright LSP language server gets spawned from the nvim
  environment, the first approach seems to me "more correct."

  Also, run via either

    $ pipenv run python bin/pythag3.py 20 30
    (3, 4, 5)
    (5, 12, 13)
    (7, 24, 25)
    (8, 15, 17)
    (20, 21, 29)

    $ pipenv run bin/pythag3.py 50 42
    (3, 4, 5)
    (5, 12, 13)
    (7, 24, 25)
    (8, 15, 17)
    (9, 40, 41)
    (12, 35, 37)
    (20, 21, 29)

  where I am using

    #!/usr/bin/env python

  as the shebang line.

2022-10-20:

  Some pyenv factoids:

  1. pyenv manages Python environments NOT Python virtual environments
  2. pyenv a shell function
     - versions for bash, ksh, zsh, fish
     - pyenv is a shell function that calls /usr/bin/pyenv (written in Bash)
     - it modifies the existing shell instead of creating a new one
     - it calls into a vast Bash shell infrastructure
  3. Each python environment managed by pyenv needs its own pipenv
  4. "pyenv shell subcommand sets and shows the shell specific Python version
     - "pyenv shell" does not create a new shell, it modifies current one
     - multiple versions of Python can be enabled with it
     - will use this to define python and pypy in same environment
  5. "pyenv rehash" subcommand needs to be called when Python versions installed

2023-08-06:

  Pipx: Install and Run Python Applications in Isolated Environments

  Pipenv, or managing a virtual environment manually, is a bit overkill
  if all you want to do is just install an external Python program. Pipx
  is not for installing Python libraries, te packages need entry points.

  Pip will step on what Pacman manages.

  Pipx can automatically creates a virtual environment, installs the
  package, and add a link for it to ~/.local/bin

    $ pipx install pycowsay
      installed package pycowsay 0.0.0.1, installed using Python 3.11.3
      These apps are now globally available
        - pycowsay
    done!

    $ pycowsay I am a cow

      ----------
    < I am a cow >
      ----------
       \   ^__^
        \  (oo)\_______
           (__)\       )\/\
               ||----w |
               ||     ||

    $ digpath pycowsay
    /home/grs/.local/bin/pycowsay

    $ ls -l (digpath pycowsay)
    lrwxrwxrwx 1 grs grs 49 Aug  6 13:54 /home/grs/.local/bin/pycowsay ->
                     /home/grs/.local/pipx/venvs/pycowsay/bin/pycowsay*

  When developimg for pipx, make sure to include an entry_points section in
  the  setup.py file for the application"

    setup(
        # other arguments here...
        entry_points={
            'console_scripts': [
                'foo = my_package.some_module:main_func',
                'bar = other_module:some_func',
            ],
            'gui_scripts': [
                'baz = my_package_gui:start_func',
            ]
        }
    )

2023-08-01:
  Installed python pytest onto gauss17 & euler7.

    sudo pacman -Syu python-pytest

2023-08-24:
  A lot of the following information, I got from beginning here:

    https://bernat.tech/posts/pep-517-and-python-packaging/

  There are 3 types of Python package distributions:

    1. source tree
    2. source distribution
    3. wheels (no build operations done on the user's computer)

  Only the second two types get uploaded to PyPI. The first one requires you to
  feed GIT repo information to pip.

  The setup.py process is old. The distutils package was created in 2000.  You
  wrote an imperative script to slog through every step of the install process.
  At the time all distributions were source distribitions. To install a source
  distribution pip more or less did the following steps:

    1. Discover the package.
    2. Download the source distribution and extract the package.
    3. Run "python setup.py install.

  The package maintainer wrote the setup.py script. The package maintainer used

    $ python setup.py sdist   # to generate the the distribution
    $ python setup.py upload  # to upload to a central repository (now deprecated!)

  In 2013 the twine tool was invented to upload the package.

  In 2004 setuptools was created for Python 2.6. This Python utility was built
  upon the distutils package. This helped with dependency management and provided
  many other additional features like the ability to declare and automatically
  install dependencies.

  There were some problems:

     - Lots of monkey copied setup.py files out in the wild.
     - Pip ran the setuptools installed on the user's system, not necessarily
       the one the maintainer used to generate the package.
     - Both sutuptools & distutils were handcuffed by backward compatibility.
     - How to handle other build tools loke cpython?
     - Whole historically driven, backward compatible, process became almost
       impossible to grok.

  To address the problem, two PEPs created.

    - PEP-517: A build system independent format for build trees (2015-2017)
    - PEP-518: Specifying Minimum Build System Requirements for Python Projects (2016)

  These PEPs allowed the creation of declaritive packaging tools tuned to the
  package's use case and unshackled from distutils and setuptools cruft.
  Though PEP-517 was accepted in 2017, pip took a while to implement it.

2023-08-24:

  Moving forward.

  I don't need a Python package management system backwardly compatible to
  Python 2.4. If you want to use a version of Python before 3.4, God bless you,
  use old deprecated packages and toolchains. Pay developers fairly to update
  them. But please, don't bother those who want to live in the middle of the
  21st century. Nor insist volenteer maintainers keep packages irrationally
  backward compatible.

  Since I quite like the Python 3.10 Match-Case statement, it is unlightly
  I will use any version of Python before 3.10 (unless you pay me well with
  lots of money). See PEP-636 for why I am so excited about structural pattern
  matching.

  Instead of involking the backend through setup.py, backends are involked
  through modules & functions. All packaging backends must provide an API that
  implements two methods "build_wheel" and "build_sdist" at the very minimum.

  Since pip 19.0 (pip currently on 23.2.1 for Python 3.11) pip supports PEP-517
  when a project has a pyproject.toml file in its root directory.

  For examples of package configurations for many different backends, see
  Bernát Gábor's GitHub profile: https://github.com/gaborbernat.

2023-08-24:
  Installed python Flit onto gauss17 & euler7.

    sudo pacman -Syu python-flit

  When using pip, Flit requires Python 3 and therefore needs to be installed
  using the Python 3 version of pip. Python 2 modules can be distributed using
  Flit, but need to be importable on Python 3 without errors.

2023-08-27:

  As I continue moving forward and educating myself on how to maintain PyPI
  packages...

  Since so far I have only written pure Python packages, I will use the Flit
  as my packaging backend for PyPI. I will be following the Flit documentation
  located on PyPA: https://flit.pypa.io and I will use Flit's GitHub repo itself
  as a guide to set up a Flit based repo: https://github.com/pypa/flit

  My first python package to push to PyPI will be grscheller.datastuctures.
  Version numbers 0.X.Y will be used while data structures are still a part of
  the grscheller-python-libs repo. Will use 1.0.X when I break it out to its own
  GitHub repo, and 1.1.0 for first version pushed out tp PyPI.

  Why use Flit? From its PyPa website:

    - flit init helps you set up the information Flit needs about your package.

    - Subpackages are automatically included: you only need to specify the
      top-level package.

    - Data files within a package directory are automatically included.
      Missing data files has been a common packaging mistake with other tools.

    - The version number is taken from your package’s __version__ attribute,
      so that always matches the version that tools like pip see.

    - flit publish uploads a package to PyPI, so you don’t need a separate tool
      to do this.

  Document steps/decisions I take:

  01. Simplfy datastuctures/__init__.py

        """Python datastructures which do not throw exceptions."""

        __version__ = "0.1.0"

        from .dqueue import *
        from .stack import *

      This will be the only location where __version__ will be recorded.

  02. Copy LICENSE file from root of grscheller-python-libs repo to
  grscheller/datastructures/ directory.

  03. Put the following copyright notices at the beginning of both stack.py and
  dqueue.py

    # Copyright 2023 Geoffrey R. Scheller
    #
    # Licensed under the Apache License, Version 2.0 (the "License");
    # you may not use this file except in compliance with the License.
    # You may obtain a copy of the License at
    #
    #     http://www.apache.org/licenses/LICENSE-2.0
    #
    # Unless required by applicable law or agreed to in writing, software
    # distributed under the License is distributed on an "AS IS" BASIS,
    # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    # See the License for the specific language governing permissions and
    # limitations under the License.

  04. Initialize grsscheller/datasstructures for use by Flit.

    $ cd ~/devel/grscheller-python-libs/grscheller/datastructures
    $ flit init
    Module name: grscheller.datastructures
    Try again.
    Module name: datastructures
    Author: Geoffrey R. Scheller
    Author email: geoffrey@scheller.com
    Home page:
    Choose a license (see http://choosealicense.com/ for more info)
    1. MIT - simple and permissive
    2. Apache - explicitly grants patent rights
    3. GPL - ensures that code based on this is shared with the same terms
    4. Skip - choose a license later
    Enter 1-4: 2

    Written pyproject.toml; edit that file to add optional extra info.

  Created the following pyproject.toml file:

    [build-system]
    requires = ["flit_core >=3.2,<4"]
    build-backend = "flit_core.buildapi"

    [project]
    name = "datastructures"
    authors = [{name = "Geoffrey R. Scheller", email = "geoffrey@scheller.com"}]
    license = {file = "LICENSE"}
    classifiers = ["License :: OSI Approved :: Apache Software License"]
    dynamic = ["version", "description"]

  Based on what the Flit does for its own GitHub repo, I added

    [project.urls]
    Documentation = "https://github.com/grscheller/datastructures/README.md"
    Source = "https://github.com/grscheller/datastructures"
    Changelog = "https://grscheller/grscheller/datastructures/CHANGELOG.md"

2023-08-27:

  Next steps are to get grscheller registered with PyPI and figure out how to
  associate datastructures with the name grscheller.datastructures.

  05. Went to PyPI.org and set up a PyPI account with two-factor authentication.
      Usng same two-factor authentication service as DevSecOps at work.

      user name: grscheller

      When I click "Your Projects" I get:

        You have not uploaded any projects to PyPI, yet. To learn how
        to get started, visit the Python Packaging User Guide.

        https://packaging.python.org/

  06. Create GitHub Repo: https://github.com/grscheller/datastructures

      Created on GitHub with just an Apache 2.0 boilerplate license.

        $ cd ~/devel/grscheller-python-libs-submodules/
        $ mkdir grscheller
        $ cd grscheller

      Copied over package datastructure package from grscheller-python-libs the
      repo. Added .pytset_cache/ to .gitignore file.

        $ set PYTHONPATH /home/grs/devel/grscheller-python-libs-submodules
        $ cd
        $ pytest --pyargs grscheller.datastructures
        ======================================= test session starts ========================================
        platform linux -- Python 3.11.3, pytest-7.4.0, pluggy-1.2.0
        rootdir: /home/grs
        collected 8 items

        devel/grscheller-python-libs-submodules/grscheller/datastructures/tests/test_dqueue.py ...    [ 37%]
        devel/grscheller-python-libs-submodules/grscheller/datastructures/tests/test_stack.py .....   [100%]

        ======================================== 8 passed in 0.02s =========================================
        $ cd -
        $ pwd
        /home/grs/devel/grscheller-python-libs-submodules/grscheller/datastructures

      Committed changes to datastructures repo and pushed up to GitHub.

    07. Remove datastructures from grscheller-python-libs and add back as a GIT
        submodule. Updated PYTHONPATH in fish to

          $ set PYTHONPATH /home/grs/devel/grscheller-python-libs-submodules /home/grs/devel/grscheller-python-libs

        Might want a write a shell script to juggle $PYTHONPATH

        Removed datastructures from grscheller-python-libs repo and pushed
        change to GitHub.

    TODO: Consider just pushing boring_math and func_tools to their own GIT
          repos and doing away with grscheller-python-libs???

    Hold off adding datastructures back as a submodule. Also will probably
    just drop func_tools and move boring_math to its own repo.

2023-08-29:

  Abandoned idea of submodules. Will push boring-math to its own repo. Will drop
  func_tools in lieu of just using itertools and functools from the Python
  standard libraries.

  08. Before pushing grscheller.datastructures to PyPI, first set things up to
      install the package with pip from GitHub.

      Create a git tag for the 0.2.0.0 version on datastructures:

        $ git tag -a v0.2.0.0 -m "First version grscheller.datastructures released on GitHub"
        $ git push prigin v0.2.0.0

      Source code for this tag is now downloadable from GitHub web frontend in
      either zip or tar.gz format.

  Not sure how pip will handle the grscheller part of the package name.
  Will I need to put a grscheller directory in the repo for this to
  work? Other packages just use an unqualified package name to have pip
  install it, see

      https://github.com/NiklasTiede/TinyHTTPie
      https://the-coding-lab.com/2021/8-publishing-at-pypi/

  for a setuptools/twine example which only has pip use an unqualified
  name. I doubt "datastructures" would be available and wouldn't want to
  use such a generic name without namespacing it. If only unqualified
  names can be used, I'd have to come up with a unique name expressing
  its purpose. Maybe non-burping-red-drangon-datastructures?

  No sense worrying until it fails.

  Before continuing with step 09, try installing package with pip via GitHub.

  First see if pip is working correctly.

      $ set PIP_REQUIRE_VIRTUALENV false
      $ pip install pip-install-test
      error: externally-managed-environment

      × This environment is externally managed
      ╰─> To install Python packages system-wide, try 'pacman -S
          python-xyz', where xyz is the package you are trying to
          install.

          If you wish to install a non-Arch-packaged Python package,
          create a virtual environment using 'python -m venv path/to/venv'.
          Then use path/to/venv/bin/python and path/to/venv/bin/pip.

          If you wish to install a non-Arch packaged Python application,
          it may be easiest to use 'pipx install xyz', which will manage a
          virtual environment for you. Make sure you have python-pipx
          installed via pacman.

      note: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages.
      hint: See PEP 668 for the detailed specification.

  OK, Arch does not want me to molest its Python configuration outside of
  Pacman. I'll just continue using PYTHONPATH when using datastructures with the
  system Python. To test pip, I'll need to create a virtual environment.

    $ set PIP_REQUIRE_VIRTUALENV true
    $ pip install pip-install-test
    ERROR: Could not find an activated virtualenv (required).

  Should I just use venv or pyenv? Well, might have well leverage my investment
  in pyenv and reacquaint myself with it.

  On euler7,

    $ pyenv versions
    * system (set by /home/grs/.local/share/pyenv/version)
      3.8.12
      3.9.7
      3.10.2

    $ pyenv uninstall 3.8.12
    $ pyenv uninstall 3.8.12 3.9.7 3.10.2
    pyenv: remove /home/grs/.local/share/pyenv/versions/3.8.12? [y|N] y
    pyenv: 3.8.12 uninstalled
    pyenv: remove /home/grs/.local/share/pyenv/versions/3.9.7? [y|N] y
    pyenv: 3.9.7 uninstalled
    pyenv: remove /home/grs/.local/share/pyenv/versions/3.10.2? [y|N] y
    pyenv: 3.10.2 uninstalled

    $ pyenv versions
    * system (set by /home/grs/.local/share/pyenv/version)

  These versions were for web frameworks which force web-kiddies to use
  old versions of Python. At least they were not too crufty.

  I'll install the same version of Python Arch uses.

    $ python --version
    Python 3.11.5

    $ pyenv install 3.11.5
    Downloading Python-3.11.5.tar.xz...
    -> https://www.python.org/ftp/python/3.11.5/Python-3.11.5.tar.xz
    Installing Python-3.11.5...

    BUILD FAILED (Arch Linux using python-build 20180424)

    Inspect or clean up the working tree at /tmp/python-build.20230829131800.93756
    Results logged to /tmp/python-build.20230829131800.93756.log

    Last 10 log lines:
    Traceback (most recent call last):
      File "<frozen runpy>", line 189, in _run_module_as_main
      File "<frozen runpy>", line 148, in _get_module_details
      File "<frozen runpy>", line 112, in _get_module_details
      File "/tmp/python-build.20230829131800.93756/Python-3.11.5/Lib/ensurepip/__init__.py", line 4, in <module>
        import subprocess
      File "/tmp/python-build.20230829131800.93756/Python-3.11.5/Lib/subprocess.py", line 104, in <module>
        from _posixsubprocess import fork_exec as _fork_exec
   gg ModuleNotFoundError: No module named '_posixsubprocess'
    make: *** [Makefile:1880: install] Error 1

  Same error when I try installing Python 3.10.13.

  Did work for Python 3.8.18.
  Fails for Python 3.9.0, different error.
  Fails for 3.10.1. Not interested in using any version before this one.

  Seems that pyenv moved where it stores its stuff

      ~/.pyenv/shims -> /home/grs/.local/share/pyenv/shims

  OK, wasted enough time with pyenv. I'll just use the system python and
  a virtual environment.

  Create a Python virtual environment with system python.

      $ cd ~/devel
      $ python -m venv venv_system
      $ ls venv_system/
      bin/  include/  lib/  lib64@  pyvenv.cfg
      $ ls venv_system/bin
      $ ls venv_system/bin/
      activate      activate.fish  pip*   pip3.11*  python3@
      activate.csh  Activate.ps1   pip3*  python@   python3.11@

  Now lets activate it.

      $ source venv_system/bin/activate.fish
      (venv_system)$

  Will supress the (venv_system) part of the prompt below.

      $ string join \n $PATH
      /home/grs/devel/venv_system/bin
      /home/grs/.local/share/pyenv/shims
      /usr/lib/jvm/java-17-openjdk/bin
      ...

      $ file venv_system/bin/python
      venv_system/bin/python: symbolic link to /usr/bin/python

      $ python --version
      Python 3.11.5

  Now test to see if pip now works.

      $ pip install pip-install-test
      Collecting pip-install-test
        Downloading pip_install_test-0.5-py3-none-any.whl (1.7 kB)
      Installing collected packages: pip-install-test
      Successfully installed pip-install-test-0.5

      $ python
      Python 3.11.5 (main, Aug 28 2023, 20:02:58) [GCC 13.2.1 20230801] on linux
      Type "help", "copyright", "credits" or "license" for more information.
      >>> import pip_install_test
      Good job!  You installed a pip module.

      Now get back to work!
      >>> exit()

      $ pip uninstall pip-install-test
      ...

      $ pypi
      Set $PYTHONPATH to /home/grs/devel/pypi:/home/grs/devel/grscheller-python-libs
      $ pytest --pyargs grscheller.datastructures
      ================================== test session starts ===================================
      platform linux -- Python 3.11.5, pytest-7.4.0, pluggy-1.2.0
      rootdir: /home/grs/devel/junk
      collected 8 items

      tests/test_dqueue.py ...                                                           [ 37%]
      tests/test_stack.py .....                                                          [100%]

      =================================== 8 passed in 0.01s ====================================
      $ pypi
      Removed $PYTHONPATH

      $ pytest --pyargs grscheller.datastructures
      ================================== test session starts ===================================
      platform linux -- Python 3.11.5, pytest-7.4.0, pluggy-1.2.0
      rootdir: /home/grs/devel/junk
      collected 0 items

      ================================= no tests ran in 0.00s ==================================
      ERROR: module or package not found: grscheller.datastructures (missing __init__.py?

  Good, ready to see how well grscheller.datafiles installs from its GitHub
  repo.

  09. Try installing datastructures package fromm its GitHub repo into a Python
      Virtual environment.

        $ pip install git+https://github.com/grscheller/datastructures@v0.2.0.0
        Collecting git+https://github.com/grscheller/datastructures@v0.2.0.0
          Cloning https://github.com/grscheller/datastructures (to revision v0.2.0.0) to /tmp/pip-req-build-l1y94lvt
          Running command git clone --filter=blob:none --quiet https://github.com/grscheller/datastructures /tmp/pip-req-build-l1y94lvt
          Running command git checkout -q 3a6bd777768ee515855cd15b4f5dc6e3f454c512
          Resolved https://github.com/grscheller/datastructures to commit 3a6bd777768ee515855cd15b4f5dc6e3f454c512
          Installing build dependencies ... done
          Getting requirements to build wheel ... error
          error: subprocess-exited-with-error
        
          × Getting requirements to build wheel did not run successfully.
          │ exit code: 1
          ╰─> [15 lines of output]
              Traceback (most recent call last):
                File "/home/grs/devel/venv_system/lib/python3.11/site-packages/pip/_vendor/pyproject_hooks/_in_process/_in_process.py", line 353, in <module>
                  main()
                File "/home/grs/devel/venv_system/lib/python3.11/site-packages/pip/_vendor/pyproject_hooks/_in_process/_in_process.py", line 335, in main
                  json_out['return_val'] = hook(**hook_input['kwargs'])
                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                File "/home/grs/devel/venv_system/lib/python3.11/site-packages/pip/_vendor/pyproject_hooks/_in_process/_in_process.py", line 118, in get_requires_for_build_wheel
                  return hook(config_settings)
                         ^^^^^^^^^^^^^^^^^^^^^
                File "/tmp/pip-build-env-0huuhuq1/overlay/lib/python3.11/site-packages/flit_core/buildapi.py", line 31, in get_requires_for_build_wheel
                  module = Module(info.module, Path.cwd())
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                File "/tmp/pip-build-env-0huuhuq1/overlay/lib/python3.11/site-packages/flit_core/common.py", line 59, in __init__
                  raise ValueError("No file/folder found for module {}".format(name))
              ValueError: No file/folder found for module datastructures
              [end of output]
        
          note: This error originates from a subprocess, and is likely not a problem with pip.
        error: subprocess-exited-with-error
        
        × Getting requirements to build wheel did not run successfully.
        │ exit code: 1
        ╰─> See above for output.
        
        note: This error originates from a subprocess, and is likely not a problem with pip.

      Progress! Failed getting requirements to build the "wheel", but a sort of
      expected it to. Says more configuration is needed in order to build the
      "wheel." Didn't they use to call something like this an egg?

      It caught on that flit was used as the build tool. Need to figure out if
      I need to do something with FLIT or with the package to configure it so
      that this wheel thingy can be built.

  So far, clone the repo it works. Pip clones the repo and knows the FLIT is the backend, but
  something (FLIT? pip?) does not know how to get the requirements to build the
  wheel.
           
