#!/bin/sh
#
# Trims off duplicate and non-existant directories
# for colen separated lists of UNIX PATH components.
#
# Usages: pathtrim /first/path/component:/second/path/coponent:.
#         PATH="$(pathtrim)"
#

IFS=':'

if [ $# -eq 0 ]
then
    Paths="$PATH"
else
    Paths="$1"
fi

## Standarize the $PATH list:
#  - remove redundant / and :
#  - remove trailing /'s on directory names
#  - /./ -> / 
#  - escape tabs and spaces
#  - chose not handle \n and \v in file and directory names
#
sedScript='s!/+!/!g
           s!:+!:!g
           s!/:!:!g
           s!/\./!/!g
           s!:\./!:!g
           s! !\\ !g
           s!	!\\	!g
           s!/$!!
           s!^:!!
           s!:$!!'
Paths=$(printf %s "$Paths" | sed -E -e "$sedScript")

## Approximate arrays to store actual and relative paths,
#  drop non-existant absolute paths, drop duplicates.
cnt=0
for Path in $Paths
do
    case $Path in
        /*) if readlink -e "$Path" >/dev/null
            then
                temp="$(readlink -e "$Path")"
                nn=0; Found=no
                while [ $nn -lt $cnt ]
                do
                    nn=$((nn + 1))
                    eval [ "\$temp" = "\$Path_$nn" ] && Found=yes && break
                done
                if [ $Found = no ]
                then
                    cnt=$((cnt + 1))
                    eval Path_$cnt="\"$temp\""
                fi
            fi
            ;;
        *)  nn=0; Found=no
            while [ $nn -lt $cnt ]
            do
                nn=$((nn + 1))
                eval [ "\$Path" = "\$Path_$nn" ] && Found=yes && break
            done
            if [ $Found = no ]
            then
                cnt=$((cnt + 1))
                eval Path_$cnt="$Path"
            fi
            ;;
    esac
done

## Construct new path string and send to stdout
Paths= ; nn=0
while [ $nn -lt $cnt ]
do
    nn=$((nn + 1))
    eval Paths=\$Paths\$Path_$nn:
done
printf '%s\n' "${Paths%:}"

