# A Pythagorean Triple generation program

A Pythagoean Triple is a tuple `(a, b, c)` such that `a^2 + b^2 = c^2`.

This program generates all possible pythagorean triples where
`gcd(a, b, c) = 1` and `a, b, c > 0`.

Implemented in Haskell using the Cabal buildtool and the
Arch Linux Haskell dynamic library infrastructure.

## Table of Contents

* [Usage](#usage)
* [Design Considerations](#design-considerations)
* [Build Considerations](#build-considerations)
* [CHANGELOG](CHANGELOG.md)

## Usage

```
pythagTriples  [-o1|-o2|-f|-fs|-h] number"
  where"
    number = number of triples to print"
  and"
    -o1 Triples (a, b, c) are generated in lexiconical order,
        that is a < b < c, where a,b,c have no common factors.
        Algorithm prints all possible b's and c's before
        going onto the next a.
    -o2 Triples (a, b, c) are generated ordered first by b
        then by a,  For each b, all a < b are generated.
    -f  Use a fast algorithm where triples (a, b, c) are such
        that a is odd, b is even, and a,b,c have no common
        factors.
    -fs Use above fast algorithm, but sort results a < b < c.
    -h  Print usage and general information.
```

All algorithms only print triples with no common factors.

## Design Considerations

1. These algorithms generate pathagorean triples with no common factors.

   ```
       a^2 + b^2 = c^2  where gcd(a, b, c) = 1
                          and 0 < a < b < c
   ```

   When checking for common factors, we need to check just two
   of `a, b, c` because by factoring out a common factor of
   any two we show the the square of the third, and henced the
   third itself, has the same common factor.

   Choosing `gcd(a, b, c)` geometrically this is the right choice
   since as right triangles

   ```
       (3, 4, 5) and (6, 8, 10) and (4, 3, 5)
   ```

   are similar and thus the same except for scale or orientation.

2. There is no such thing as a equilateral pyathogorean triangle.

   ```
       a^2 + a^2 = c^2 => 2*a^2 = c^2 => sqrt(2) = c/a
   ```

   but the square root of `2` is not rational!

3. The ordered algorthm generates all possible triples in lexiconical order,
   that is `a < b < c`.

   As `b` gets larger, eventually the difference in length
   beween `c` and `b` is less than `1`.

   ```
                  *
                  *    *       c
          fixed a *         *
                  *               *
                  *                    *
                  * * * * * * * * * * * * *
                         vary b
   ```

   Hence, `c-b < 1` => no more triples.

   ```
      a^2 + b^2 = c^2
      a^2 = c^2 - b^2 = (c-b)*(c+b) < c + b
      a^2 < sqrt(a^2 + b^2) + b
      (a^2 - b)^2 < a^2 + b^2
      a^4 - 2*a^2*b + b^2 < a^2 + b^2
      a^2 - 2*b < 1
      b > (a^2 - 1)/2
   ```

   Therefore, we only need to check values of b for which

   ```
      a+1 <= b <= (a^2 - 1)/2
   ```

   From running the code, we see that both <= cases happen.

4. Running the code also seems to show that the hypotenuse `c`
   is always odd.

   Let's show that this is universally true:

   We know not both `a` and `b` even, otherwise `a, b, c` not in
   lowest terms.  If one even and the other odd, then `c` is odd.

   But what about the case if `a` and `b` both odd?  That would
   imply `c` could be even.  Concider this case,

   ```
      a^2 + b^2 = c^2
      (2*m+1)^2 + (2*n+1)^2 = (2*p)^2
      4*m^2 + 4*m + 1 + 4*n^2 + 4*n + 1 = 4*p^2
      4*(m^2 + n^2) + 4*(m + n) + 2 = 4*p^2
      2*(m^2 + n^2) + 2*(m + n) + 1 = 2*p^2
      1 = 2*( p^2 - m^2 - n^2 - m - n)
   ```

   But `1` is not even, therefore `c` always odd.

   This means that if `a` is odd, we need to only check for `b` even,
   and via versa.

5. I came across a faster algorithm which produces unordered results,

   ```
      [(m^2 - n^2, 2*m*n, m^2 + n^2) | m <- [1 ..] , n <- [1 .. m-1]]
   ```

   Also seems to produce results where `gcd(a,b,c) > 1`
   like `(8, 6, 10)` and `(40, 42, 58)`.

## Build The code

This project was originally about me learning how to Use
the Stack buildtool.  Pathagorean Triples was just being an
interesting fairly self contained topic to base the project on.

Stack just does not play nice with the Arch Linux Haskell build
infrastructure.  As a result, I switched to Cabal as my build
tool.

### Original Stack Build

A package.yaml file was used to configure the build.  This allowed
the hpack utility, or stack using the Hpack module internally, to
create a pythag-triples.cabal file.

I had been checking generated files into GIT source code control.
It is my understanding that this is the best practice since it
allows others to reproduce the build with just Cabal or with
Stack without Hpack.

The following is a list of these generated files and where they
came from,

* stack.yaml: generated by `stack init`
* pythag-triples.cabal: generated by `stack init`
* Setup.hs: generated by `cabal init`
* stack.yaml.lock: generated by `stack build`

On 2022-08-10 was able to rebuild project via

```
   $ stack init --force
   $ stack build
   $ stack install
   $ pythagTriples 200
```

This installs the executable in `~/.local/bin/pythagTriples`.

### Problems With Original Build

1. Ignores entirely Arch Linux GHC infrastructure.
2. Did do a dynamic build, but against shared libraries installed in ~/.stack/
3. Neovim LSP totally confused - ghcide "failed to load packages"

Decided to try and learn Cabal, again, and redo this project as
a native Arch Build.

### Cabal Build

I use Cabal from the Arch Linux Pacman package cabal-install.  I do not
even install the Haskell Static Libraries.  As a result, I have modified
`~/.cabal/config` from what `cabal update` would provide if missing.

```
    < -- library-vanilla: True
    > library-vanilla: False
    
    < -- shared:
    > shared: True
    
    < -- executable-dynamic: False
    > executable-dynamic: True
    
    < -- overwrite-policy:
    > overwrite-policy: always
    
    <   -- ghc-options:
    >   ghc-options: -dynamic
```

So far, I have used only packages either provided by Arch Linux
or built by myself.  For now, I have not felt the need to use
Cabal sandboxes to avoid "Cabal Hell."

I use `cabal install` to directly install executables into `~/.cabal/bin`.
