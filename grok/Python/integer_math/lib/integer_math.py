"""Library of functions of an integer pure math nature.

Note: Type checking the responsibility of the calling function.
"""

__author__ = "Geoffrey Scheller"

import sys

__all__ = ['gcd', 'lcm', 'prime_list', 'prime_range',
           'pythag3',
           'ackermann',
           'drop', 'take',
           'fibonacci', 'fibonacci_list', 'fibonacci_tuple',
           'fibonacci_mult', 'fibonacci_mult_list', 'fibonacci_mult_tuple']

## Number Theory mathematical Functions.

def gcd(n, m):
    """Uses Euclidian algorithm to compute the gcd of two integers.

    Takes two integers, returns gcd >= 0.

    Note: gcd(0,0) returns 0 but in this case the gcd does not exist.
    """

    while m > 0:
        n, m = m, n % m

    return n


def lcm(n, m):
    """Finds the least common multiple of two integers.
       Takes two integers, returns lcm >=0.
    """

    common = gcd(n, m)
    n //= common
    m //= common

    return abs(n*m*common)


def prime_list(n=2, m=100):
    """Return an list of primes where n <= prime < m

    Uses the Sieve of Eratosthenes algorithm

    Usage: primes = prime_list(n=2, m=100)
    """

    if n >= m or m < 3:
        return []
    if n < 2:
        n = 2

    sieve = [x for x in range(3, m, 2) if x % 3 != 0]
    stop = int(m**(0.5)) + 1
    front = -1
    for prime in sieve:
        front += 1
        if prime > stop:
            break
        for pot_prime in sieve[-1:front:-1]:
            if pot_prime % prime == 0:
                sieve.remove(pot_prime)

    if n <= 3 < m:           # We missed [2, 3] but
        sieve.insert(0, 3)   # saved about 60% for
    if n <= 2 < m:           # the initial storage
        sieve.insert(0, 2)   # space.

    # return sieve after trimming unwanted values
    return [x for x in sieve if x >= n]


def prime_range(n=2, m=100):
    """Return an iterator for values generated by
    the prime_list function for n <= prime < m
    """

    return iter(prime_list(n, m))


## Functional utility functions

def drop(n, iterator):
    """Drop the first n elements on an iterator"""

    try:
        for _ in range(n):
            next(iterator)
    except StopIteration:
        return iterator

    return iterator


def take(n, iterator):
    """Iterator returning next n elements from iterator"""

    for _ in range(n):
        try:
            next_val = next(iterator)
        except StopIteration:
            return
        yield next_val


## Pythagorian Triples related mathematical functions.

def pythag3(a_max=3, all_max=None):
    """This iterator finds all primative pythagorian triples
    up to a given level.  A pythagorian triple are three
    integers (a,b,c) such that a^2 + b^2 = c^2 where
    x,y,z > 0 and gcd(a,b,c) = 1

    If called with one argument, generates all triples with
    a <= a_max

    If called with two arguments generate all triples with
    a <= a_max and a,b,c <= all_max
    """

    if a_max < 3:
        a_max = 2

    if all_max is None:
        # No more triples beyond this value of b.
        b_max = lambda a: (a**2 - 1)//2
    else:
        if all_max < 5:
            all_max = 4
        # Cap triples to those with sides no bigger than all_max
        if all_max < a_max + 2:
            a_max = all_max - 2
        b_max = lambda a: min((a**2 - 1)//2, int((all_max**2 - a**2)**0.5))

    c_max = int((a_max**2 + b_max(a_max)**2)**(0.5))
    squares = {}
    for hypotenuse in range(5, c_max + 1, 2):    # hypotenuse always odd
        squares[hypotenuse**2] = hypotenuse

    for a in range(3, a_max + 1):
        for b in range(a + 1, b_max(a) + 1):
            csq = a**2 + b**2
            if csq in squares:
                if gcd(a, b) == 1:
                    yield (a, b, squares[csq])


# Computable but not primitive recursive functions

def ackermann(m=0, n=0):
    """Ackermann function is defined recursively by:

    ackermann(0,n) = n+1
    ackermann(m,0) = ackermann(m-1,1)
    ackermann(m,n) = ackermann(m-1, ackermann(m, n-1)) for n,m > 0
    """

    # Model a function stack with a list, then
    # evaluate innermost ackermann function first.
    acker = [m, n]

    while len(acker) > 1:
        m, n = acker[-2:]
        if m < 1:
            acker[-1] = acker.pop() + 1
        elif n < 1:
            acker[-2] = acker[-2] - 1
            acker[-1] = 1
        else:
            acker[-2] = m - 1
            acker[-1] = m
            acker.append(n-1)

    return acker[0]


## Fibonacci related mathematical functions.

def fibonacci(fib0=0, fib1=1, count=100):
    """Returns an iterator to a Fibonacci sequence whose
    first two terms are f0 and f1.  The iterator ends
    after count times.

    Please note: fib0 and fib1 can be any objects where
    the "+" operator has been defined.
    """

    n = 0
    while n < count:
        n = n + 1
        yield fib0
        fib0, fib1 = fib1, fib0+fib1


def fibonacci_mult(fib0=0, fib1=1, count=100):
    """Returns an iterator to a Fibonacci sequence using
    * instead of +.  The first two terms are f0 and f1.
    The iterator ends after count times.

    Please note: fib0 and fib1 can be any objects where
    the "*" operator has been defined.
    """

    n = 0
    while n < count:
        n = n + 1
        yield fib0
        fib0, fib1 = fib1, fib0*fib1


def fibonacci_list(fib0=0, fib1=1, count=100):
    """Returns an list with a fibonacci sequence"""

    return list(fibonacci(fib0, fib1, count))


def fibonacci_tuple(fib0=0, fib1=1, count=100):
    """Returns a tuple with a fibonacci sequence"""

    return tuple(fibonacci_list(fib0, fib1, count))


def fibonacci_mult_list(fib0=0, fib1=1, count=100):
    """Returns an list with a fibonacci sequence using * instead of +."""

    return list(fibonacci_mult(fib0, fib1, count))


def fibonacci_mult_tuple(fib0=0, fib1=1, count=100):
    """Returns a tuple with a fibonacci sequence using * instead of +."""

    return tuple(fibonacci_mult_list(fib0, fib1, count))


if __name__ == '__main__':
    sys.exit(0)
