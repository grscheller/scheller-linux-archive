# Notes on Haskell 2010 Report.
* A summary of the [Haskell 2010 Language Report][HR].  
* Do not know where I downloaded the text version of this summary.
* Converted to MarkDown by me.

[HR]: https://www.haskell.org/onlinereport/haskell2010/ "Haskell 2010 Report"

## Part 1: Overview
I. Top down structure (Gross overview):
   A. Modules - top most level
      1. Provides way to control namespaces
      2. Helps reuse software in large programs
   B. Module consists of a collection of declarations
      1. Types of Declarations
         a. ordinary values
         b. datatypes
         c. type classes
         d. fixity information
   C. Next level down are expressions
      1. Has a value and a static type
      2. Heart of Haskell programming "in the small"
   D. Lowest Level is lexical structure
      1. Captures the concrete representation of programs in text files
II. Haskell Kernel (Factoids)
   A. Not formally specified
      1. Slightly sugared variant of the (typed) lambda calculus
      2. Straightforward denotational semantics
      3. Programs get reduced (desugared) to the kernel before symantics
      4. Provides straight forward reasoning about programs
      5. Provides useful guidelines for language implementation
      6. Reflects true nature of the beast
   B. Language does not have statements (not imperative)
   C. Language is non-strict (lazy)
      1. expressions evaluated only if necessary
   D. Data is immutable
      1. Names are bound to expressions, not storage areas in memmory
      2. Once bound, can not be changed
   E. Functions arguments are separated by whitespace
   ```
      myFunction arg1 arg2 arg3
   ```
   F. The Prelude also adds complexity on top of the sugar added to
      the kernel.  (Kernal, Compilier, Prelude boundaries can be
      implementation dependent.)
III. Haskell Namespaces
   A. Six kinds of names in Haskell
      1. variables and Constructors denote values
      2. Type system consists of
         a. type variables
         b. type constructors
         c. type classes
      3. Module names
   B. Two constraints on naming
      1. Names of variables and type variables are identifiers beginning
         with lowercase letters or underscore.  Other types of names are 
         identifiers begin with uppercase letters
      2. An identifier must not be used as the name of a type constructor
         and a (type) class in the same scope.
   C. Concrete naming example
      1. Int may simultaneously be the name of a module, class, and 
         constructor within a single scope.

## Part 2: Lexical Structure
I. Notational conventions
```
   [pattern]      optional
   {pattern}      zero or more repetitions
   (pattern)      grouping
   pat1 ǀ pat2    choice
   pat<pat'>      difference - elements generated by pat except those by pat'
```
II. BNF-like syntax
III. Haskell uses Unicode character set
   A. Infarstructure biased toward ASCII for historical reasons
   B. Compilers expected to make use of new versions of Unicode
   C. Syntax depends on how characters are defined by Unicode consortium.
   D. This choise makes Unix no longer completely Text/Binary
      agnostic. (small price for UTF-8)
IV. Lexical Program Structure
   A. See page 8 of 2010 standard for gory details.
   B. Lexical analysis uses "maximal munch" rule
      1. Longest possible lexeme is read
         a. = is reserved but == and ~= are not
         b. case is reserved but cases is not
      2. Any kind of whitespace is a proper deliniter for lexemes
      3. Only ANY type of characters are valid in Haskell programs
         a. graphic character
         b. whitespace character
      4. newline ➔ cr lf ǀ cr ǀ lf ǀ ff
      5. Comments are valid whitespace
         a. Ordinary comments begin with -- and extend to newline
         b. The sequence of dashes must not form part of a legal lexeme
            i. --> and |-- don't begin comments
            ii. --foo does start a comment
            iii. func "foo--bar" does not start a comment. 
         c. Nested commets start {- and end -}
            i. No legal lexeme starts with {-
            ii. Can be nested to any depth
            iii. Nested comments used for compiler pragmas
            iv. Comments are not lexically analysed.  Any instance of
              `{-` or `-}` within a string or end-of-line comment will
              interfer with the nested comment.
   C. Identifiers and Operators
      1. identifier ➔ letter{letter ǀ digit ǀ _ ǀ '}
         a. Case sensitive, _ is treated as lower case
         b. Separate namespaces
            i. variable identifiers start with lower case letter
            ```
               varid ➔ (small {small ǀ large ǀ digit ǀ '})<reservedid>
            ```
            ii. constructor identifiers start with upper case letter 
            ```
               conid ➔ large {small ǀ large ǀ digit ǀ '}
            ```
   D. Reserved identifiers:
   ```
       reservedid ➔ case ǀ class ǀ data ǀ default ǀ deriving ǀ do ǀ else
                  ǀ foreign ǀ if ǀ import ǀ in ǀ infix ǀ infixl ǀ infixr
                  ǀ instance ǀ let ǀ module ǀ newtype ǀ of ǀ then
                  ǀ type ǀ where ǀ _
   ```
   E. Operator symbols:
   ```
      special  ➔   | ǀ , ǀ ; ǀ [ ǀ ] ǀ ` ǀ { ǀ }
      symbol ➔ asciiSymbol ǀ unicodeSymbol<special ǀ _ ǀ " ǀ '>
      reservedop ➔ .. ǀ : ǀ :: ǀ = ǀ \ ǀ | ǀ <- ǀ -> ǀ @ ǀ ~ ǀ =>
      varsym ➔ (symbol<:> {symbol})<reservedop ǀ dashes>
      consym ➔ ( : {symbol})<reservedop>
   ```
      1. An operator symbol starting with a colon is a constructor
      2. Otherwise it is an ordinary identifier
      3. `:`, `[]`, and `[a,b]` list constructors are built into the base 
         language (kernel???) to make more compatible with the LISP 
         family of functional languages.
      4. With the exception of the prefix operator -, all other operators 
         are infix.  May need parentheses to force - prefix:
      ```
         ghci> 4 - (- 3)
         7
      ```
      5. Operators are just functions and can be called as such:
      ```
         ghci> 2 + 3
         5
         ghci> (+) 2 3
         5
      ```
      6. Functions have infix forms too:
      ```
         ghci> mod 8 3
         2
         ghci> 8 `mod` 3
         2
      ```
    F. The six different type of names:
    ```
       varid
       conid
       tyvar ➔ varid
       tycon ➔ conid
       tycls ➔ conid
       modid ➔ {conid .} conid
    ```
       1. Variables and type variables begin with small letters.
          The others with capital letters.
          (aside: that is why True is capitalized)
       2. Variables and constructors have infix forms, the 
          others do not.
       3. Variables, (data) constructors, type constuctors, and 
          type classes can have "qualified" names, but not
          type variables or module names.
          ```
             qvarid ➔ [modid .] varid
             qconid ➔ [modid .] conid
             qtycon ➔ [modid .] tycon
             qtycls ➔ [modid .] tycls
             qvarsym ➔ [modid .] varsym
             qconsym ➔ [modid .] consym
          ```
    G. Sample Lexical Analysis:
       1. `f.g` lexes as 3 tokens
       ```
          f . g
       ```
       2. `F.g` lexes as a qualified name
       ```
          F.g
       ```
       3. `f..` lexes as 2 tokens
       ```
          f ..
       ```
       4. `F..` lexes as a qualified .
       5. `F.`  lexes as 2 tokens
       ```
          F .
       ```
       6. Prelude.+ is an infix operator with same fixity as + in the Prelude
    H. Numeric Literals:
    ```
       decimal ➔ digit{digit} 
       octal   ➔ octit{octic}
       hexadecimal ➔ hexit{hexit}

       integer ➔ decimal
               ǀ  0o octal ǀ 0O octal
               ǀ  0x hexadecimal ǀ 0X hexadecimal

       float ➔ decimal.decimal[exponent]
             ǀ  decimal[exponent]

       exponent ➔ (eǀE)[+ǀ-]decimal
    ```
       1. Floating point literals are always expressed with
          decimal notation.
       2. Digits before and after decimal point, no whitespace.
       3. Negative numbers may require some care.
       4. Tping of literals to be discussed later.
    I. Character and String Literals
    ```
       char    ➔  ' (graphic<'ǀ\> ǀ space ǀ escape<\&>) '
       string  ➔  " {graphic<"ǀ\> ǀ space ǀ escape ǀ gap} "
       escape  ➔  \ (charesc ǀ ascii ǀ decimal ǀ o octal ǀ x hexadecimal)
       charesc ➔  a ǀ b ǀ f ǀ n ǀ r ǀ t ǀ v ǀ \ ǀ " ǀ ' ǀ &
       ascii   ➔  ^ cntrl ǀ NUL ǀ SOH ǀ STX ǀ ETX ǀ EOT ǀ ENQ ǀ ACK
               ǀ   BEL ǀ BS ǀ HT ǀ LF ǀ VT ǀ FF ǀ CR ǀ SO ǀ SI ǀ DLE
               ǀ   DC1 ǀ DC2 ǀ DC3 ǀ DC4 ǀ NAK ǀ SYN ǀ ETB ǀ CAN
               ǀ   EM ǀ SUB ǀ ESC ǀ FS ǀ GS ǀ RS ǀ US ǀ SP ǀ DEL
       cntrl   ➔  ascLarge ǀ @ ǀ [ ǀ \ ǀ ] ǀ ^ ǀ _
       gap     ➔  \ whitechar {whitechr} \
       whitechar ➔ newline ǀ vertab ǀ space ǀ tab ǀ uniWhite
    ```
       1. Think of \& as a zero width separator.
          a. `"foo\&bar" == "foobar"`
          b. `"\SOH" is one character`
          c. `"\SO\&H" is two characters`
          d. `'\&' is illegal`

    J. Layout
       1. In the kernel language `{ ... }` is used for
          grouping and ; for expression separation.
          a. Very rarely seen used in code
          b. Sometimes useful in ghci one-liners
          c. Makes Haskell programs easier to be produced by other programs.
          d. Makes C wonks feel more at home.
          e. The ; used like in Pascal as a separator except for 
             expressions, Haskell has no statements.
        2. Layout optional, gives Haskell more of a Python feel.
          a. Culture (parser too?) puts the ; before the next 
             statement instead of after the previous one.
          b. Parser "substitutes" certain indentation with backets
             and semicolens.

        3. Example with layout:
        ```
           size :: Stack a -> Int
           size s = length (stkToLst s) where
                      stkToLst Empty          = []
                      stkToLst (MkStack x s)  = x:xs where xs = stkToLst s
        ```
        4a. How the parser would interpret above:
        ```
           size :: Stack a -> Int
           ;size s = length (stkToLst s) where
                      {stkToLst Empty          = []
                      ;stkToLst (MkStack x s)  = x:xs where {xs = stkToLst s
           }}
        ```
        4b. How a C coder would hand code it, tastes vary:
        ```
           size :: Stack a -> Int;
           size s = length (stkToLst s) where {
                        stkToLst Empty  = [];
                        stkToLst (MkStack x s) = x:xs where {
                              xs = stkToLst s
                        } 
           }
        ```
        4c. In a more Haskellian style:
        ```
           size :: Stack a -> Int
           ; size s = length (stkToLst s) where
                      { stkToLst Empty  = []
                      ; stkToLst (MkStack x s) = x:xs where
                                          { xs = stkToLst s }
                      }
        ```
        4d. How I'd type it into ghci (except all on one line):
        ```
           let size s=length (s2L s) where {s2L Empty=[];s2L (MKStack x s)=x:xs where {xs=s2L s}}
        ```
        5. Layout and non-layout can be mixed:
        ```
           f x = let a = 1; b = 2
                     g y = exp2
                  in exp1
        ```
        this makes `a, b, g` all part of the same "layout list."

## Part 3: Expressions
I. Introduction
   A. This part describes the syntax and informal syntax of Haskell 
      expressions, including their translation into the Haskell
      kernel where appropriate.
   B. Except in the case of "let" expressions, these kernel translations
      preserve static and dynamic semantics.
   C. Free variables and constructors used always refer to entities 
      defined in the Prelude.  (may not necessarily be in scope)
II. Structure of expressions
```
   exp      ➔  infixexp :: ［context =>］ type    (expression type signature)
            ǀ  infixexp

   infixexp ➔  lexp qop infixexp                  (infix operator application)
            ǀ  - infixexp                         (prefix negation)
            ǀ  lexp

   lexp     ➔  \ apat1 ... aptn -> exp            (lambda abstraction, n ≥ 1)
            ǀ  let decls in exp                   (let expression)
            ǀ  if exp [;] then exp [;] else exp   (conditional)
            ǀ  case exp of { alts }               (case expression)
            ǀ  do { stmts }                       (do expression)
            ǀ  fexp

   fexp     ➔  [fexp] aexp                        (function application)

   aexp     ➔  qvar                               (variable)
            ǀ  gcon                               (general constructor)
            ǀ  literal
            ǀ  ( exp )                            (parenthesized expression)
            ǀ  ( exp1, ... , expn )               (tuple, n ≥ 2)
            ǀ  [ exp1, ... , expn ]               (list, n ≥ 1)
            ǀ  [ exp1, ［, exp2］ .. ［exp3］]    (arithmetic sequence)
            ǀ  [ exp | qual1, ..., qualn ]        (list comprehension, n ≥ 1)
            ǀ  ( infixexp qop )                   (left section)
            ǀ  ( qop<-> infixexp )                (left section)
            ǀ  qcon { fbind1, ..., fbindn }       (labeled construction, n ≥ 0)
            ǀ  aexp<qcon> { fbind1, ..., fbindn } (labeled update, n ≥ 1)
```
   A. Use parenthesis to override infix operator's fixity.
   B. Consecutive operators with the same precedence must both 
      be right or left associative.
   C. Negation is the only prefix operator.  No postfix operators.
   D. Grammar ambiguous regarding the extent of lambda abstractions,
      let expressions, and conditionals.  Ambiguity resolved with
      meta-rule that each of these constructs extends as far right
      as possible.
      ```
         Examples:                     Parses as:
         f x + g y                     (f x) + (g y)
         - f x + y                     (- (f x)) + y
         let { ... } in x + y          let { ... } in (x + y)
         z + let {...} in x + y        z + (let {...} in (x+y))
         f x y :: Int                  (f x y) :: Int
         \ x -> a+b :: Int             \x -> ((a+b) :: Int)
      ```
III. Errors
   A. Errors during expression evaluation, denoted by ⊥ (bottom), are 
      indistinguishable by a Haskell program from non-termination.
   B. Since Haskell is a non-strict language (only evaluate function
      arguments if necessary), all Haskell types include ⊥ .
   C. When evaluated, errors cause immediate program termination.
   D. Prelude provides two such funtions:
      * `error     :: String -> a`
      * `undefined :: a`
   E. Very implementation dependent.
IV. Variables, Constructors, Operators, and Literals
```
   aexp  ➔   qvar                      (variable)
         ǀ   gcon                      (general constructor)
         ǀ   literal

   gcon  ➔   ()
         ǀ   []
         ǀ   (,{,})
         ǀ   qcon

   var   ➔   varid ǀ ( varsym )        (variable)
   qvar  ➔   qvarid ǀ ( qvarsym )      (qualified variable)  
```
