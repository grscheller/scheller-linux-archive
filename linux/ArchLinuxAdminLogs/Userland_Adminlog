Purpose: For things installed locally as an unprivalleged user.

2016-07-29:
  Installed Anaconda Python into /home/geoff/opt/anaconda3.
    Adjusted .bash_profile to put it in the path before
    system python.

    $ /home/geoff/opt/anaconda3/bin/python --version
    Python 3.5.2 :: Anaconda 4.1.1 (64-bit)

    $ /usr/bin/python --version
    Python 3.5.2

    $ /usr/bin/python2 --version
    Python 2.7.12

    Note: See 2018-01-25 for configuring conda virtual environments,
          without having to put base Anaconda on your $PATH.

2016-08-01:
  For scanning journalctl output, some useful options -
    journalctl -f : follows like tail -f
    journalctl -x : Augment log lines with explanation texts

  For querying installed packages -
    pacman -Qet : List all explicitly installed packages

2016-08-17:
  Added a simplistic ~/.vimrc file containing the following:
    syntax off
    set encoding=utf-8
    set fileencoding=utf-8
    set tabstop=4
    set shiftwidth=4
    set expandtab

  It also contains comments explaining what I want to accomplish.

2016-08-30:
  Configured Cabal to install Haskell Cabal packages into geoff
  home directory for Cabal packages not yet rolled into Arch
  Linux Pacman packages.

    $ mkdir -p .cabal/bin
    $ cabal update

  Installed codo-notation Cabal package

    $ cabal install codo-notation

    Cabal001: codo-notation

  Note: Cabal is "NOT" a true package manager.  Subsequent
    "cabal installs" can break previous ones.  This is known
    as "Cabal Hell."

    1. Cabal can install packages globally - NEVER DO THIS!!!
    2. Be prepared to blow away the .cabal directory and
       start over.
    3. Possible to do Cabal on a per project basis using Cabal
       sandboxws.  I wish to avoid this.  Also, periodically
       monitor if Arch Linux Repos pick up these Cabal packages.
    4. Like I did with Pacman, using "Cabal#:" so that I know
       what I have currently installed via Cabal.  Use

         $ grep 'Cabal...:' userland_Adminlog.txt

       to get the list of Cabal installs.  Starting the
       count at 001.

  Cabal man page says that it is "cabal - a system for building
  and packaging Haskell libraries and programs".

2016-09-16:
  Perl6 is "finally?" stable enough to try out.  There seems to
  be two AUR's for it, rakudo and rakudo-star.  Much confusion
  for which to use.  So, by passing AUR and install locally.

  Installed the rakudo-star-2016.07 tarball into /home/geoff/local.
  Built a perl6 that seems to work.  Some minor problems with the
  regression tests when I built it (missing tests I think?).  When
  I run perl6, it suggests I use for line editting either:
    1. panda install Readline
    2. panda install Linenoise
    3. use rlwrap

  But, panda not installed!  So, I cloned it from git-hub following
  the directions from there.

    $ git clone --recursive git://github.com/tadzik/panda.git

  and followed README.md instructions build it using my shinny
  new perl6.  Build fails to complete, but without "errors."

  Now, the first thing suggested in README.md is to use a perl5
  based utility called rakudobrew to build and install it.  This
  seems to be similar to sbt abd lien in its use case.  Cloned
  it directly into ~/.rakudobrew.

    $ git clone https://github.com/tadzik/rakudobrew ~/.rakudobrew

  Now, I tried to use it to build the package manager panda:

    $ rakudobrew build panda

  It complains that I have not told it what version of perl6 to use.
  Why not the only bloody one on the path???  Then I realize that
  I am dealing with something like sbt or lien, which wants to
  itself build or install whatever perl6 version I indicate.

2016-09-17:
  I decided to change the use case of ~/local.  It is more likely
  that Arch packages will (eventually) be more up-to-date than
  anything I build, I will put ~/local/bin just before ~/bin
  on my path.  (At work, I've been stuck on outdated CentOS 6.7
  for way, way, way too long.)

  Now, my Linux path is:

    $ ~/bin/path
    /home/geoff/.cabal/bin
    /home/geoff/opt/anaconda3/bin
    /usr/local/sbin
    /usr/local/bin
    /usr/bin
    /opt/cuda/bin
    /usr/lib/jvm/default/bin
    /usr/bin/site_perl
    /usr/bin/vendor_perl
    /usr/bin/core_perl
    /home/geoff/local/bin
    /home/geoff/local/share/perl6/site/bin
    /home/geoff/bin
    .

2016-09-17:
  Back to Perl6, after some digging, the rakudo-star AUR package
  is broken and rakudo package last updated 2016-08-20.  I'll
  go with rakudo (see guass17_AdminLog.txt).

2016-10-13:
  Using stack as my build tool for Haskell -

  Installed into /usr/local/bin via.

    $ curl -sSL https://get.haskellstack.org/ | sh

  Install ghc locally to your home directory:

    $ stack setup

  Created a stack "sandbox" and using with git.

    $ stack --resolver ghc-7.10.3 new pythagTriples simple
    cd pythagTriples
    git init
    git add develLog.txt LICENSE Setup.hs pythagTriples.cabal
    git add stack.yaml src/Main.hs
    vi develLog.txt
    git status
    git commit

  Later, created a .gitignore file based on what was recommended
  by Chris Allen in 'https://www.howistart.org/posts/haskell/1'.

    $ cat .gitignore
    dist
    dist-*
    cabal-dev
    *.o
    *.hi
    *.chi
    *.chs.h
    *.dyn_o
    *.dyn_hi
    .hpc
    .hsenv
    .cabal-sandbox/
    cabal.sandbox.config
    *.prof
    *.aux
    *.hp
    *.eventlog
    .stack-work/
    *.swp

  Run ghci outside of a project:

    $ stack ghci
    Run from outside a project, using implicit global project config
    Using resolver: lts-7.1 from implicit global project's config file:
        /home/geoff/.stack/global-project/stack.yaml
    Configuring GHCi with the following packages:
    GHCi, version 8.0.1: http://www.haskell.org/ghc/  :? for help
    Loaded GHCi configuration from /tmp/ghci7977/ghci-script
    Prelude>

  Run another version of ghci outside of a project:

    $ stack --resolver ghc-7.10.3 ghci
    Run from outside a project, using implicit global project config
    Using resolver: ghc-7.10.3 specified on command line
    Configuring GHCi with the following packages:
    GHCi, version 7.10.3: http://www.haskell.org/ghc/  :? for help
    Prelude>

  OK, I need to figure out which version I should be using.  Seems
  that the lts-7.1 is using a newer version of GHCi than ghc-7.10.3!
  Until I am better "educated", I'll stick to lts-7.1.

2016-10-15:
  The latest long term support version of Haskell on Stackage,
  https://www.stackage.org/, is LTS Haskell 7.3 (ghc-8.0.1).  The
  defaults stack generates in stack.yaml are really out of date.
  The lts-3.5 on Arch Linux caused me a lot of confussion, but it
  did tell me that the only supported versions of ghc for OS
  key 'linux64-ncurses6' are GhcVersion 7.10.3, GhcVersion 8.0.1.

  So, I'll stick with lts-7.3 until the next LTS release.

  Globally I installed lts-7.3 via

    $ stack --resolver lts-7.3 setup

  and made lts-7.3 the default  by editing
  ~/.stack/global-project/stack.yaml, where the non-comment
  contents of this file are now:

    extra-package-dbs: []
    packages: []
    extra-deps: []
    resolver: lts-7.3

  Now, a comment in this file directs me to the file
  ~/.stack/config.yaml as being the default template for
  new projects.  This file refers to the website
  http://docs.haskellstack.org/en/stable/yaml_configuration/
  for how to configure this file.  After consulting this
  website, the contents of ~/.stack/config.yaml are now:

    templates:
      params:
        author-email: geoffrey@scheller.com
        author-name: 'Geoffrey Scheller'
        copyright: 'Copyright: (c) 2016 Geoffrey R. Scheller'
        github-username: grscheller

  I left the param 'category: value' off until I understand
  it better.  Seems that it should be set on a per project
  basis anyway.

2016-10-15:
  When creating a new stack project, use

    $ stack new foofoo new-template

  This will create:
    LICENSE
    Setup.hs
    foofoo.cabal
    stack.yaml
    app/Main.hs
    src/Lib.hs
    test/Spec.hs

  This seems a much better starting point than the ones I
  fumbled to create above.

  Aside: Don't know why it put it in the Web category?

2016-10-16:
  Seems that the Haskell/Stack world has moved onto lts-7.4.

  I saw this when I tried to build something with stack.

  Updated stack itself:

    $ stack update

2016-10-20:
  Updated stack to use lts-7.4 when outside a project:

  Changed

    resolver: lts-7.3

  in ~/.stack/global-project/stack.yaml

2016-18-2016:
  Change the X keymappings to make Caps-Lock a second Escape key.

  Rt Click desktop ->
    Applications -> Settings -> Sessions and Startup ->
      Application Autostart tab

      Now add the following entry:

      Name: Keymapping
      Description: Make caps-lock an escape key
      Command: xmodmap -e "clear Lock" -e "keysym Caps_Lock = Escape"

  Restart X.

2017-01-29:
  I had noticed that some package (I think haskell-cmark)
  required ghc 8.0.1-1 as a dependency.  Also noticed that
  the version of stack in the Arch Repos was later than
  the one I previous installed in /usr/local.

  Removed previous stack Haskell infrastructure.

    $ rm -rf ~/.stack
    $ rm ~/.local/bin/{cabal,happy,alex}
    # rm /usr/local/bin/stack

  Installed stack and haskell-stack packages with
  pacman.  Initialized new sandbox into my home
  directory.

    $ stack setup

  and created a new project with

    $ stack new junkTest simple

  From the stack.yaml file, I see the following

    resolver: lts-7.18
    # require-stack-version: ">=1.3"

  Also,

    $ whence ghc
    /usr/bin/ghc

    $ stack exec whence ghc
    /home/geoff/.stack/programs/x86_64-linux/ghc-ncurses6-8.0.1/bin/ghc
    /usr/bin/ghc

  Running stack the first time created a default YAML file

    ~/.stack/global-project/stack.yaml

  With the following non-comment content:

    flags: {}
    extra-package-dbs: []
    packages: []
    extra-deps: []
    resolver: lts-7.18

  Versions of ghc

    $ /usr/bin/ghc --version
    The Glorious Glasgow Haskell Compilation System, version 8.0.1

    $ ~/.stack/programs/x86_64-linux/ghc-ncurses6-8.0.1/bin/ghc --version
    The Glorious Glasgow Haskell Compilation System, version 8.0.1

  Finally I editted the file

    ~/.stack/config.yaml

  as follows

    templates:
      params:
        author-name: geoffrey@scheller.com
        author-email: 'Geoffrey Scheller'
        copyright: 'Copyright: (c) 2017 Geoffrey R. Scheller'
        github-username: grscheller
        category: 'Learning Haskell'

  From these sites:

    https://docs.haskellstack.org
    https://haskell-lang.org/tutorial/stack-build

  I got the following:

    We define project to mean a directory that contains a
    stack.yaml file, which specifies how to build a set of
    cabal packages.  We define package to be a package with
    a .cabal file.

    A cabal package is identified by a single .cabal file, and
    has 0 or 1 libraries, and 0 or more executables, test suites,
    and benchmarks.

    A Stack project has 1 or more cabal packages, and can build
    them all at the same time.

  Initialize a new project with

    $ stack new junkTest simple

  Build the project with

    $ stack build

  Test the project with

    $ stack test

  Install the project with

    $ stack install

    For the simple project, this just installs
    the executable into ~/.local/bin

  An existing Cabal package can be initialize
  a stack.yaml file to use Stack via

    $ stack init

  inside the directory with the package's .cabal file.
  Stack will attempt to determine a package set compatible
  with the packages requested in the .cabal file.

  To get all sorts of configuration info, use

    $ stack path

  To find out the versions of libraries which stack installed

    $ stack list-dependencies
    base 4.9.0.0
    junkTest3 0.1.0.0

2017-02-01:
  Installed networking components.

    Pacman: python2-iwscan python2-wpactrl

  Noticed following warnings in /var/log/wicd/wicd.log - 

    2017/01/21 19:50:13 :: WARNING: python-iwscan not found, falling back to using iwlist scan.
    2017/01/21 19:50:13 :: WARNING: python-wpactrl not found, falling back to using wpa_cli.

  At several wifi hotspots, not all, I've had to configure static IP addresses.

2018-01-20:
  Updated my Anaconda Python Distribution:

    $ conda update --all

  Now we have

    $ whence python
    /home/geoff/opt/anaconda3/bin/python
    /usr/bin/python

    $ python --version
    Python 3.6.4 :: Anaconda custom (64-bit)

    $ /usr/bin/python --version
    Python 3.6.4

  This is the first step in trying to work thru some Python based
  machine learning tutorials.  I hope to also incorporate Jupyter
  notebooks into this endeavor.

2018-01-25:
  Have to use conda virtual environments since ~/opt/anaconda3/bin
  contaminates path with old versions of /usr/bin utilities.

  In my ~/.bashrc file I put

    alias conda=~/opt/anaconda3/bin/conda

  and in ~/.bash_profile I removed ~/opt/anaconda3/bin from my $PATH.

  After these changes,

    $ conda -V
    conda 4.4.7

    $ conda update conda
    Solving environment: done

    # All requested packages already installed.

  Use the following to determine a list of available python versions
  to configure an anaconda virtual environment,

    $ conda search "^python$"

  Since I am a bleeding edge type guy, I will create a conda virtual
  environment called "play" with the most recent version of python
  given by above command,

    $ conda create -n play python=3.6.4 anaconda
    Solving environment: done

    ## Package Plan ##

      environment location: /home/geoff/opt/anaconda3/envs/play

      added / updated specs: 
        - anaconda
        - python=3.6.4


    The following packages will be downloaded:

        package                    |            build
        ---------------------------|-----------------
        sqlite-3.21.0              |       h1bed415_0         1.5 MB

    The following NEW packages will be INSTALLED:

        anaconda:        custom-py36hbbc8b67_0   
        ca-certificates: 2017.08.26-h1d4fec5_0   
        certifi:         2017.11.5-py36hf29ccca_0
        libedit:         3.1-heed3624_0          
        libffi:          3.2.1-hd88cf55_4        
        libgcc-ng:       7.2.0-h7cc24e2_2        
        libstdcxx-ng:    7.2.0-h7a57d05_2        
        ncurses:         6.0-h9df7e31_2          
        openssl:         1.0.2n-hb7f436b_0       
        pip:             9.0.1-py36h6c6f9ce_4    
        python:          3.6.4-hc3d631a_1        
        readline:        7.0-ha6073c6_4          
        setuptools:      38.4.0-py36_0           
        sqlite:          3.21.0-h1bed415_0       
        tk:              8.6.7-hc745277_3        
        wheel:           0.30.0-py36hfd4bba0_1   
        xz:              5.2.3-h55aa19d_2        
        zlib:            1.2.11-ha838bed_2       
    
    Proceed ([y]/n)?y

    Downloading and Extracting Packages
    sqlite 3.21.0: ############################################### | 100% 
    Preparing transaction: done
    Verifying transaction: done
    Executing transaction: done
    #
    # To activate this environment, use:
    # > source activate play
    #
    # To deactivate an active environment, use:
    # > source deactivate
    #

  The following two aliases will be needed in .bashrc

    alias activate='source ~/opt/anaconda3/bin/activate'
    alias deactivate='source ~/opt/anaconda3/bin/deactivate'

  Well, Anaconda's horrible activate/deactivate scripts don't seem to
  get along with my bash environment.

    $ sh
    sh-4.4$ source ~/opt/anaconda3/bin/activate play
    (play) sh-4.4$ whence python
    /home/geoff/opt/anaconda3/envs/play/bin/python
    /usr/bin/python
    (play) sh-4.4$ source ~/opt/anaconda3/bin/deactivate
    sh-4.4$ whence python
    /usr/bin/python
    sh-4.4$ exit
    $ 

  In my opinion, each shell should have its own very cleanly written
  version.  Then a "lowest common denominator" activation script can
  select the correct version for the user's shell.  That way shell
  scripting is not stuck in the 1970's.

  Lets create a .profile for the Bourne Shell

    export PS1='$ '
    export PS2='> '

    ## Anaconda Python aliases
    alias activate='. ~/opt/anaconda3/bin/activate'
    alias deactivate='. ~/opt/anaconda3/bin/deactivate'

  Now,

    $ sh -l
    $ whence python
    /usr/bin/python
    $ activate play
    (play) $ whence python
    /home/geoff/opt/anaconda3/envs/play/bin/python
    /usr/bin/python
    (play) $ deactivate
    $ exit
    $

2018-01-30:
  Fixed annoying xscreensaver problem where login box appeared
  ~ every 20 seconds.

  Went into settings -> settings editor -> xfce4-power-man.  I
  reset every setting, which permanently removed it.  Fixed the
  problem.

  Wondering if past configurations incompatible with updates?

2018-02-05:
  Tweaked Anaconda related aliases in .bashrc:

    alias conda=~/opt/anaconda3/bin/conda
    alias actA='sh -c ". ~/opt/anaconda3/bin/activate; bash"'
    alias play='sh -c ". ~/opt/anaconda3/bin/activate play; bash"'

  Don't need to mess with the deactivate script, just ^D out
  of the bash shell.  Also, conda does not like to be called from 
  an activated anaconda environment.

2018-02-05:
  Updated Anaconda base and play environments:
    $ conda update -n base conda
    $ conda update -n base --all
    $ conda update -n play --all

  Noted that my "play" environment's python is getting downgraded
  from 3.6.4 to 3.6.3.  

  Installing "everything but the kitchen sink" seems to be a
  bad idea.  Stuff gets downgraded to meet dependencies.  Use
  conda environments with minimally installed packages.

  A GUI called Anaconda Navigator was installed into play, but
  not base???  This thing is something like Enthought's canopy?
  It is also in base, but both fail with a type error

    TypeError: byte indices must be integers or slices, not str

  when run outside a conda environment.

2018-02-05:
  Anaconda navigator-updater will run from the base anaconda environment
  but not the play environment.  From base, can modify both base and play.

2018-02-07:
  Anaconda and Canopy both seem geared for clueless scientist using out-of-date
  Linux distributions.  I want a Python development environment, not a MATLAB
  like IDE "App" geared toward hacky Fortran programmers.

  For purposes of learning Deep Learning Python development, I will use
  the Arch Linux system python and configure Arch via pacman for the
  required NVIDIA/CUDA dependencies.

  To be continued... (see ArchLinux_AdminLog.txt 2018-02-14)

2018-02-07:
  Time to figure out the Arch Haskell infarstucture.

  Up to now, I have used Stack which pretty much ignored the existing
  Arch Haskell infrastructure.  When using ghc from the command line, it failed
  to link due to the absence of the Haskell static libraries.  Instead of
  linking dynamically, I installed the static libraries via the ghc-static
  package.

  Cabal is the package description format for Haskell.  It describes a package
  and how it interacts with the language.  It provides a common infrastructure
  for building and distributing packages.  The cabal-install build tool provides
  dependency resolution and retrieves source packages from Hackage, the official
  Haskell package hosting website.  Cabal uses the GHC that you indicate; it is
  beyond its scope to manage GHC installations.

  Stack is a build system for Haskell.  Its aim is to provide extremely
  reprodicible builds.  To do this, it freezes all your dependencies, including
  the version of GHC used for the project.  It utilizes the Stackage package
  website.  Stackage contains snapshots of packages and GHC compilers which
  are compatible with each other.  When starting a project, you choose which
  Stackage snapshot to use.  It downloads and installs locally into your
  home directory which versions of GHC and other packages it needs to build
  your project.  It is built on top of Cabal and replaces cabal-install.

  My Arch Haskell infrastructure is not a Stackage snapshot.  I need to
  learn how to use Cabal directly.  This will also help me learn how to
  use stack better.

2018-02-07:
  First step is to uninstall the Haskell static libraries.  When I did 
  this (see ArchLinux_AdminLog.txt), it also uninstalled ghc!

  What I build locally to run on Arch, I'll use cabal-install with sandboxes
  and dynamic linking.  I'll use stack when I want a statically linked 
  executable I can distribute, or share a build.

  Lets see how much of the Haskell Platform I have left:

    $ pacman -Qs happy
    local/happy 1.19.8-2
        The Parser Generator for Haskell

    $ pacman -Qs alex
    local/alex 3.2.3-4
        Lexical analyser generator for Haskell

    $ pacman -Qs haddock
    local/haskell-haddock-library 1.4.5-7
        A documentation-generation tool for Haskell libraries

    $ pacman -Qs stack
    local/bluez-libs 5.48-1
        Deprecated libraries for the bluetooth protocol stack
    local/haskell-call-stack 0.1.0-5
        Use GHC call-stacks in a backward compatible way
    local/haskell-transformers-base 0.4.4-10
        Lift computations from the bottom of a transformer stack
    local/stack 1.6.3-60
        The Haskell Tool Stack

    $ pacman -Qs cabal-install

    $ pacman -Ss cabal-install
        community/cabal-install 2.0.0.1-5
        The command-line interface for Cabal and Hackage.

    $ pacman -Qs ghc
    local/ghc-libs 8.2.2-1
        The Glasgow Haskell Compiler - Dynamic Libraries
        local/haskell-call-stack 0.1.0-5
        Use GHC call-stacks in a backward compatible way
    local/haskell-deepseq-generics 0.2.0.0-5
        GHC.Generics-based Control.DeepSeq.rnf implementation
    local/haskell-extensible-exceptions 0.1.1.4-18
        extensible exceptions for both new and old versions of GHC
    local/haskell-system-fileio 0.3.16.3-8
        Consistent filesystem interaction across GHC versions

  I guess I never installed the pacman cabal-install package.

    $ sudo pacman -Syu ghc
    $ sudo pacman -Syu cabal-install

  The ghc-static package was not re-installed.

2018-02-07:
  Let's test dynamic linking, in file Main.hs put

    main = putStrLn "Hello, World!"

  and compile and run it

    $ ghc -dynamic Main.hs
    [1 of 1] Compiling Main             ( Main.hs, Main.o )
    Linking Main ...

    $ ./Main
    Hello, World!

2018-02-07:
  The cabal-install package contained the /usr/bin/cabal command:

    $ whence cabal*
    /usr/bin/cabal

  The 'cabal help' command gives a summary of the available cabal commands.

    $ cabal update
    Config file path source is default config file.
    Config file /home/geoff/.cabal/config not found.
    Writing default configuration to /home/geoff/.cabal/config
    Warning: 'nslookup' tool missing - can't locate mirrors
    Downloading the latest package list from hackage.haskell.org

  This has to be done periodically to capture newly released packages,

    $ cabal update
    Downloading the latest package list from hackage.haskell.org

  Let's create a sandbox:

    $ mkdir junk2; cd junk2
    $ cabal sandbox init
    Writing a default package environment file to
    /home/geoff/junk2/cabal.sandbox.config
    Creating a new sandbox at /home/geoff/junk2/.cabal-sandbox

  Interactively initiate the default cabal file:

    $ cabal init

  I told it to create an executable with entry point Main.hs and it
  created the boilerplate:

    module Main where

    main :: IO ()
    main = putStrLn "Hello, Haskell!"

  Need to tell cabal to use dynamic libraries for my sandbox.

    $ cabal configure --disable-library-vanilla --enable-shared --enable-executable-dynamic
    Resolving dependencies...
    Configuring junk2-0.1.0.0...

  Build the package

    $ cabal build
    Preprocessing executable 'junk2' for junk2-0.1.0.0..
    Building executable 'junk2' for junk2-0.1.0.0..
    [1 of 1] Compiling Main             ( Main.hs, dist/build/junk2/junk2-tmp/Main.dyn_o )
    Linking dist/build/junk2/junk2 ...

  Run the command

    $ dist/build/junk2/junk2
    Hello, Haskell!

  Clean things up,

    $ cabal clean
    cleaning...

  this deleted the executable and undid the 'cabal configure'.  Redoing
  these and finally,

    $ cabal run
    Preprocessing executable 'junk2' for junk2-0.1.0.0..
    Building executable 'junk2' for junk2-0.1.0.0..
    Running junk2...
    Hello, Haskell!

  seemed to want to build it again.

2018-05-23:
  Installed Cinnamon desktop environment.  Its native file manager
  is called nemo (was installed) and terminal emulator is called
  gnome-terminal (not installed, but available).  Able to find
  xfce4-terminal in the menus.

  To set xfce4-terminal as the default terminal application

    $ gsettings set org.cinnamon.desktop.default-applications.terminal exec /usr/bin/xfce4-terminal

  Now I can open a terminal by rt-clicking in nemo and <ctrl>+<alt>+t.

  To set mouse focus go to

    Settings -> Windows -> Behavior

  Also turned on "Prevent focus stealing" from here.

  Only behavior I could not achieve is not to raise the window on
  a mouse click event...

  But, scrollwheel doesn't raise window and mouse click passes
  to window, not just raises it.  <ctrl>+<clicks> don't raise
  the window.

2018-05-23:
  Moved panel to top and created new pannel on bottom.  Moved 
  "Window list app" to bottom panel (LHS) by itself. Installed
  workspace switcher app top panel.  

  Can switch workspaces via
    <cntl>+<alt>+<left arrow>  and  <cntl>+<alt>+<right arrow>  

  Can drag windows between workspaces and select workspace via
    <cntl>+<alt>+<up arrow>

  Can select amoung windows on a workspace via
    <cntl>+<alt>+<down arrow>

2018-05-24:
  Cinnamon seems very similar to XFCE, or it is so configurable that
  I have comfigured it so.  The big difference is that font size and
  colors are centrally configured in Cinammon.  Claws-mail pleasingly
  dark theme in XFCE is ignored in Cinnamon.  

  I think Cinammon themes configure groups of gui elements (panel applets,
  desktop applets, background) separately and uniformly across applications.
  Trying to overwide Claw-email colors with clawsker failed in Cinammon.

  Cinnamon lets you mix aspects of different themes fairly effortlessly.
  Until I can find some themes which give "applets" a dark background,
  Cinnamon won't work for me.  By "applet" I refer to programs that use
  GTK2 library interface, I think this is the "hook" that these "modern"
  desktops are using to Mac-i-nize the user experience.

2018-05-24:
  Got a Cinnamon theme combo that works for me,

    Window borders:  Adapta-Nokto
    Icons:           gnome
    Controls:        Adwaita
    Mouse Pointer:   Adwaita
    Desktop:         Serena

  Borders & title bars indicate what has focus.  Unfocused
  windows don't blur-out.  Window-list applet shows what
  has focus.  Controls very readable, light text on a
  medium-to-dark grey backgound.

2018-06-01:
  Will stick to Cinnamon, supplemented with some XFCE
  "apps" and "applets".  Launchers and running applications
  are nicely deconflated.  Created an info file on how to
  configure Cinnamon on Arch:

    linux/info/ArchLinuxInfo/cinnamon_conf.txt

