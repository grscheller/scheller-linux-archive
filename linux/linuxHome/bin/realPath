#!/bin/bash
#
# Resolve symlinks and print out the real path for each
# path given on the commandline.
#
# Usage: realPath /path/to/first/item another/path/to/second/item
#
# Purpose: To find the real locations of files and directories.
#          Will give some limited info on failures other than
#          just not finding anything.  Not a symlink report tool.
#
# Works well with whence,
#
#     realPath $(whence java javac scala python cc gcc ghc)
#
# Bugs: 1. Execute permission needed in all directories traversed.
#       2. Don't know how to gag FUNCNEST recursion limit error messages.
#

export FUNCNEST=50   # For safety, put a limit on the recursion,
                     # FUNCNEST=0 means no limit, but not a good
                     # idea for a script that recursively creates
                     # subshells.

# Recursively resolves all the symlinks
function followLinks() {
  Path="$1"
  currDir="$(pwd)"
  if [[ -L $Path ]]
  then
      # Basename a symlink
      symBase="$(basename "$Path")"
      symDir="$(dirname "$Path")"
      (
        cd "${symDir}" 2>/dev/null || {
            echo "$0: For ${currTarget}: Cannot access symlink ${symDir} from ${currDir}" >&2
            exit
        }
        longLS="$(ls -l "${symBase}")"
        target="${longLS#*-> }"
        followLinks "$target"
      )
  else
      # Basename not a symlink
      dirName="$(dirname "$Path")"
      baseName="$(basename "$Path")"
      (
        cd "$dirName" 2>/dev/null || {
            echo "$0: For ${currTarget}: Cannot access directory ${dirName} from ${currDir}" >&2
            exit
        }
        if [[ -e $baseName ]]
        then
            echo -n "$(pwd -P)"
            if [[ $baseName == . ]]
            then
                echo
            else
                echo "/${baseName}"
            fi
        fi
      )
  fi
}

for currTarget in "$@"
do
    followLinks "${currTarget}" || echo "$0: For ${currTarget}: Possible circular links" >&2
done
